<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        
        <link rel="shortcut icon" href="../../favicon.ico">
        

	<title>Semantics - JSON Schema</title>

        <link href="../../css/bootstrap-custom.min.css" rel="stylesheet">
        <link href="../../css/font-awesome-4.0.3.css" rel="stylesheet">
        <link rel="stylesheet" href="../../css/highlight.css">
        <link href="../../css/base.css" rel="stylesheet">

        <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
        <![endif]-->

        
        <script>
            (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
            m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
            })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

            ga('create', 'UA-36723568-3', 'mkdocs.org');
            ga('send', 'pageview');
        </script>
        
    </head>

    <body>

        <div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">

        <!-- Collapsed navigation -->
        <div class="navbar-header">
            <!-- Expander button -->
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>

            <!-- Main title -->
            <a class="navbar-brand" href="../..">JSON Schema</a>
        </div>

        <!-- Expanded navigation -->
        <div class="navbar-collapse collapse">
            <!-- Main navigation -->
            <ul class="nav navbar-nav">
            
            
                <li >
                    <a href="../..">Home</a>
                </li>
            
            
            
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">Building Schemas <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li >
                            <a href="../introduction/">Introduction</a>
                        </li>
                    
                        <li >
                            <a href="../basic_types/">Basic Types</a>
                        </li>
                    
                        <li >
                            <a href="../arrays_objects/">Arrays & Objects</a>
                        </li>
                    
                        <li >
                            <a href="../definitions_references/">Definitions & References</a>
                        </li>
                    
                        <li >
                            <a href="../multiple_types/">Multiple Types</a>
                        </li>
                    
                        <li >
                            <a href="../generic_keywords/">Generic Keywords</a>
                        </li>
                    
                    </ul>
                </li>
            
            
            
                <li class="dropdown active">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">Formal Specification <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li >
                            <a href="../grammar/">Grammar</a>
                        </li>
                    
                        <li class="active">
                            <a href="./">Semantics</a>
                        </li>
                    
                    </ul>
                </li>
            
            
            </ul>

            <!-- Search, Navigation and Repo links -->
            <ul class="nav navbar-nav navbar-right">
                <li >
                    <a rel="next" href="../grammar/">
                        <i class="fa fa-arrow-left"></i> Previous
                    </a>
                </li>
                <li class="disabled">
                    <a rel="prev" >
                        Next <i class="fa fa-arrow-right"></i>
                    </a>
                </li>
                
            </ul>
        </div>
    </div>
</div>

        <div class="container">
            <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
    
        <li class="main active"><a href="#semantics">Semantics</a></li>
        
            <li><a href="#type-restricted-schemas">Type Restricted Schemas</a></li>
        
            <li><a href="#free-type-schemas">Free Type Schemas</a></li>
        
    
    </ul>
</div></div>
            <div class="col-md-9" role="main">

<h1 id="semantics"><CENTER>Semantics</CENTER></h1>
<p><CENTER>A formal specification of how JSON Documents validate against a JSON Schema Document</CENTER></p>
<p>In this section we present a formal specification of how JSON Schema restrictions are validated against an arbitraty JSON Document. As we mentioned in the lat section, a JSON Schema can be seen as a set of restrictions for JSON Documents. In this context, we divide the semantics in two cases:</p>
<ul>
<li><a href="#type-restricted-schemas"><code>When type is restricted</code></a></li>
<li><a href="#free-type-schemas"><code>When type is not restricted</code></a></li>
</ul>
<p>For this, we should define some distinctions between schemas depending on the presence <code>"type"</code> restriction and it's value. These new definitions are represented in the following table:</p>
<table>
<thead>
<tr>
<th>schema</th>
<th>type restriction</th>
</tr>
</thead>
<tbody>
<tr>
<td>String Schema</td>
<td><code>"type": "string"</code></td>
</tr>
<tr>
<td>Numeric Schema</td>
<td><code>"type": "integer"</code>, <code>"type": "number"</code></td>
</tr>
<tr>
<td>Boolean Schema</td>
<td><code>"type": "boolean"</code></td>
</tr>
<tr>
<td>Null Schema</td>
<td><code>"type": "null"</code></td>
</tr>
<tr>
<td>Array Schema</td>
<td><code>"type": "array"</code></td>
</tr>
<tr>
<td>Object Schema</td>
<td><code>"type": "object"</code></td>
</tr>
<tr>
<td>Multiple Schema</td>
<td><code>"type": [t<sub>1</sub> . . . t<sub>n</sub>]</code> or no type restriction present</td>
</tr>
</tbody>
</table>
<h2 id="type-restricted-schemas">Type Restricted Schemas</h2>
<h3 id="strings-restrictions">Strings Restrictions</h3>
<p>Let <strong>S</strong> be a String Schema and <strong>J</strong> a JSON document. We say that <strong>J</strong> validates against <strong>S</strong> if for each key:value pair <strong>k</strong> in <strong>S</strong> one of the following holds:</p>
<ul>
<li><strong>k</strong> is <code>"type": "string"</code> and <strong>J</strong> is a string</li>
<li><strong>k</strong> is of the form <code>"minLength" : n</code> and <strong>J</strong> is a string of length at least <strong>n</strong></li>
<li><strong>k</strong> is of the form <code>"maxLength" : n</code> and <strong>J</strong> is a string of length at most <strong>n</strong></li>
<li><strong>k</strong> is of the form <code>"pattern" : r</code> and <strong>J</strong> is a string that matches the regular expression <strong>r</strong></li>
<li><strong>k</strong> is of the form <code>"anyOf": [{Sch<sub>1</sub>}, {Sch<sub>2</sub>}, ... ,{Sch<sub>n</sub>}]</code> and <strong>J</strong> validates against <em>some</em> <strong>Sch<sub>i</sub></strong>, for <strong>i</strong>=<strong>1</strong>...<strong>n</strong></li>
<li><strong>k</strong> is of the form <code>"allOf": [{Sch<sub>1</sub>}, {Sch<sub>2</sub>}, ... ,{Sch<sub>n</sub>}]</code> and <strong>J</strong> validates against <em>all</em> of <strong>Sch<sub>i</sub></strong>, for <strong>i</strong>=<strong>1</strong>...<strong>n</strong></li>
<li><strong>k</strong> is of the form <code>"oneOf": [{Sch<sub>1</sub>}, {Sch<sub>2</sub>}, ... ,{Sch<sub>n</sub>}]</code> and <strong>J</strong> validates against <em>exactly one</em> of <strong>Sch<sub>i</sub></strong>, for <strong>i</strong>=<strong>1</strong>...<strong>n</strong></li>
<li><strong>k</strong> is of the form <code>"not": {Sch}</code> and <strong>J</strong> does <em>not</em> validate against <strong>Sch</strong>.</li>
</ul>
<h3 id="numeric-restrictions">Numeric Restrictions</h3>
<p>Let <strong>N</strong> be a numeric schema and <strong>J</strong> a JSON document. Then <strong>N</strong> validates against <strong>J</strong> if for each key:value pair <strong>k</strong> in <strong>N</strong>, one of the following holds: </p>
<ul>
<li><strong>k</strong> is <code>"type":"number"</code> and <strong>J</strong> is a number, or</li>
<li><strong>k</strong> is <code>"type":"integer"</code> and <strong>J</strong> is an integer number (a number without the decimal <code>.</code> marker), or</li>
<li><strong>k</strong> is <code>"multipleOf": n</code>, for some number <strong>n</strong>, and <strong>J</strong> is a number that is a multpiple of <strong>n</strong>, or </li>
<li><strong>k</strong> is <code>"minimum": n</code>, for some number <strong>n</strong>, and <strong>J</strong> is a number that is greater than or equal to <strong>n</strong>, or</li>
<li><strong>k</strong> is <code>"maximum": m</code>, for some number <strong>m</strong>, and <strong>J</strong> is a number that is lower than or equal to <strong>m</strong>, or</li>
<li><strong>k</strong> is <code>"exclusiveMinimum": true</code>, the pair <code>"minimum": n</code> for some number <strong>n</strong> is also in <strong>N</strong>, and <strong>J</strong> is a number that is greater than <strong>n</strong>, or</li>
<li><strong>k</strong> is <code>"exclusiveMaximum": true</code>, the pair <code>"maximum": m</code> for some number <strong>m</strong> is also in <strong>N</strong>, and <strong>J</strong> is a number that is lower than <strong>m</strong></li>
<li><strong>k</strong> is of the form <code>"anyOf": [{Sch<sub>1</sub>}, {Sch<sub>2</sub>}, ... ,{Sch<sub>n</sub>}]</code> and <strong>J</strong> validates against <em>some</em> <strong>Sch<sub>i</sub></strong>, for <strong>i</strong>=<strong>1</strong>...<strong>n</strong></li>
<li><strong>k</strong> is of the form <code>"allOf": [{Sch<sub>1</sub>}, {Sch<sub>2</sub>}, ... ,{Sch<sub>n</sub>}]</code> and <strong>J</strong> validates against <em>all</em> of <strong>Sch<sub>i</sub></strong>, for <strong>i</strong>=<strong>1</strong>...<strong>n</strong></li>
<li><strong>k</strong> is of the form <code>"oneOf": [{Sch<sub>1</sub>}, {Sch<sub>2</sub>}, ... ,{Sch<sub>n</sub>}]</code> and <strong>J</strong> validates against <em>exactly one</em> of <strong>Sch<sub>i</sub></strong>, for <strong>i</strong>=<strong>1</strong>...<strong>n</strong></li>
<li><strong>k</strong> is of the form <code>"not": {Sch}</code> and <strong>J</strong> does <em>not</em> validate against <strong>Sch</strong></li>
<li><strong>k</strong> is of the form <code>"enum": [val<sub>1</sub> , ... , val<sub>n]</code> and <strong>J</strong> is any <strong>val<sub>i</sub></strong> for some <strong>i</strong> in [ <strong>1</strong> , ..., <strong>n</strong> ].</li>
</ul>
<h3 id="boolean-restrictions">Boolean Restrictions</h3>
<p>Let <strong>B</strong> be a Boolean Schema and <strong>J</strong> a JSON document. We say that <strong>J</strong> validates against <strong>B</strong> if for each key:value pair <strong>k</strong> in <strong>B</strong> one of the following holds:</p>
<ul>
<li><strong>k</strong> is <code>"type": "boolean"</code> and <strong>J</strong> is either <strong>true</strong> or <strong>false</strong></li>
<li><strong>k</strong> is of the form <code>"anyOf": [{Sch<sub>1</sub>}, {Sch<sub>2</sub>}, ... ,{Sch<sub>n</sub>}]</code> and <strong>J</strong> validates against <em>some</em> <strong>Sch<sub>i</sub></strong>, for <strong>i</strong>=<strong>1</strong>...<strong>n</strong></li>
<li><strong>k</strong> is of the form <code>"allOf": [{Sch<sub>1</sub>}, {Sch<sub>2</sub>}, ... ,{Sch<sub>n</sub>}]</code> and <strong>J</strong> validates against <em>all</em> of <strong>Sch<sub>i</sub></strong>, for <strong>i</strong>=<strong>1</strong>...<strong>n</strong></li>
<li><strong>k</strong> is of the form <code>"oneOf": [{Sch<sub>1</sub>}, {Sch<sub>2</sub>}, ... ,{Sch<sub>n</sub>}]</code> and <strong>J</strong> validates against <em>exactly one</em> of <strong>Sch<sub>i</sub></strong>, for <strong>i</strong>=<strong>1</strong>...<strong>n</strong></li>
<li><strong>k</strong> is of the form <code>"not": {Sch}</code> and <strong>J</strong> does <em>not</em> validate against <strong>Sch</strong></li>
<li><strong>k</strong> is of the form <code>"enum": [val<sub>1</sub> , ... , val<sub>n]</code> and <strong>J</strong> is any <strong>val<sub>i</sub></strong> for some <strong>i</strong> in [ <strong>1</strong> , ..., <strong>n</strong> ].</li>
</ul>
<h3 id="null-restrictions">Null Restrictions</h3>
<p>Let <strong>Nl</strong> be a Null Schema and <strong>J</strong> a JSON document. We say that <strong>J</strong> validates against <strong>Nl</strong> if for each key:value pair <strong>k</strong> in <strong>Nl</strong> one of the following holds:</p>
<ul>
<li><strong>k</strong> is <code>"type": "null"</code> and <strong>J</strong> equals <strong>null</strong></li>
<li><strong>k</strong> is of the form <code>"anyOf": [{Sch<sub>1</sub>}, {Sch<sub>2</sub>}, ... ,{Sch<sub>n</sub>}]</code> and <strong>J</strong> validates against <em>some</em> <strong>Sch<sub>i</sub></strong>, for <strong>i</strong>=<strong>1</strong>...<strong>n</strong></li>
<li><strong>k</strong> is of the form <code>"allOf": [{Sch<sub>1</sub>}, {Sch<sub>2</sub>}, ... ,{Sch<sub>n</sub>}]</code> and <strong>J</strong> validates against <em>all</em> of <strong>Sch<sub>i</sub></strong>, for <strong>i</strong>=<strong>1</strong>...<strong>n</strong></li>
<li><strong>k</strong> is of the form <code>"oneOf": [{Sch<sub>1</sub>}, {Sch<sub>2</sub>}, ... ,{Sch<sub>n</sub>}]</code> and <strong>J</strong> validates against <em>exactly one</em> of <strong>Sch<sub>i</sub></strong>, for <strong>i</strong>=<strong>1</strong>...<strong>n</strong></li>
<li><strong>k</strong> is of the form <code>"not": {Sch}</code> and <strong>J</strong> does <em>not</em> validate against <strong>Sch</strong></li>
<li><strong>k</strong> is of the form <code>"enum": [val<sub>1</sub> , ... , val<sub>n]</code> and <strong>J</strong> is any <strong>val<sub>i</sub></strong> for some <strong>i</strong> in [ <strong>1</strong> , ..., <strong>n</strong> ].</li>
</ul>
<h3 id="array-restrictions">Array Restrictions</h3>
<p>Let <b>A</b> be an Array Schema and <b>J</b> a JSON document. We say that <b>J</b> validates against <b>A</b> if for each key:value pair <b>k</b> in <b>A</b> one of the following holds:</p>
<ul>
<li><b>k</b> is <code>"type": "array"</code> and <b>J</b> is an array</li>
<li><b>k</b> is <code>"items": s</code> and <b>J</b> is an array such that every element validates against <strong>s</strong></li>
<li><b>k</b> is <code>"items": [s<sub>1</sub> , ... , s<sub>n</sub>]</code> and <b>J</b> is an array <code>[a<sub>1</sub> , ... , a<sub>m</sub>]</code> such that every element <strong>a<sub>i</sub></strong> validates against <strong>s<sub>i</sub></strong> with <strong>i</strong> â‰¤ Min(<strong>m</strong>,<strong>n</strong>).</li>
<li><b>k</b> is <code>"additionalItems": false</code>, there is a key:value pair <code>"items": [s<sub>1</sub> , ... , s<sub>n</sub>]</code> in <strong>A</strong> and <strong>J</strong> is an array with at most n elements. </li>
<li><b>k</b> is <code>"minItems": n</code> and <b>J</b> is an array with at least n elements</li>
<li><b>k</b> is <code>"maxItems": n</code> and <b>J</b> is an array with at most n elements</li>
<li><b>k</b> is <code>"uniqueItems": true</code> and <b>J</b> is an array with all elements different from each other</li>
<li><strong>k</strong> is of the form <code>"anyOf": [{Sch<sub>1</sub>}, {Sch<sub>2</sub>}, ... ,{Sch<sub>n</sub>}]</code> and <strong>J</strong> validates against <em>some</em> <strong>Sch<sub>i</sub></strong>, for <strong>i</strong>=<strong>1</strong>...<strong>n</strong></li>
<li><strong>k</strong> is of the form <code>"allOf": [{Sch<sub>1</sub>}, {Sch<sub>2</sub>}, ... ,{Sch<sub>n</sub>}]</code> and <strong>J</strong> validates against <em>all</em> of <strong>Sch<sub>i</sub></strong>, for <strong>i</strong>=<strong>1</strong>...<strong>n</strong></li>
<li><strong>k</strong> is of the form <code>"oneOf": [{Sch<sub>1</sub>}, {Sch<sub>2</sub>}, ... ,{Sch<sub>n</sub>}]</code> and <strong>J</strong> validates against <em>exactly one</em> of <strong>Sch<sub>i</sub></strong>, for <strong>i</strong>=<strong>1</strong>...<strong>n</strong></li>
<li><strong>k</strong> is of the form <code>"not": {Sch}</code> and <strong>J</strong> does <em>not</em> validate against <strong>Sch</strong></li>
<li><strong>k</strong> is of the form <code>"enum": [val<sub>1</sub> , ... , val<sub>n]</code> and <strong>J</strong> is any <strong>val<sub>i</sub></strong> for some <strong>i</strong> in [ <strong>1</strong> , ..., <strong>n</strong> ].</li>
</ul>
<h3 id="object-restrictions">Object Restrictions</h3>
<p>Let <b>O</b> be an object Schema and <b>J</b> a JSON document. We say that a keyword <strong>k</strong> appears in <strong>J</strong> is <strong>J</strong> contains a key:value pair of the form <strong>k: j'</strong>, for some document <strong>j'</strong>. </p>
<p>We say that <b>J</b> validates against <b>O</b> if for each key:value pair <b>k</b> in <b>O</b> one of the following holds:</p>
<ul>
<li><strong>k</strong> is of the form <code>"type": "object"</code> and <b>J</b> is an object</li>
<li><strong>k</strong> is of the form <code>"properties": {k<sub>1</sub>: s<sub>1</sub> , ... , k<sub>n</sub>: s<sub>n</sub>}</code> and <b>J</b> is an object that for each key-value pair <b>k': j'</b> in <b>J</b>, if <b>k' = k<sub>i</sub></b> for some <strong>i</strong> in [ <strong>1</strong> , ... , <strong>n</strong> ] then <b>j'</b> satisfies <b>s<sub>i</sub></b></b></li>
<li><strong>k</strong> is of the form <code>"additionalProperties": false</code> and <b>J</b> is an object such that every keyword in <b>J</b> is mentioned in <code>"properties": {k<sub>1</sub>: s<sub>1</sub> , ... , k<sub>n</sub>: s<sub>n</sub>}</code></li>
<li><strong>k</strong> is of the form <code>"additionalProperties": true</code> and <b>J</b> is an object</li>
<li><strong>k</strong> is of the form <code>"additionalProperties": s</code> and <b>J</b> is an object that for each key-value pair <b>k': j'</b> in <b>J</b> such that <b>k'</b> is different from every <b>k<sub>i</sub></b></b> in <code>"properties": {k<sub>1</sub>: s<sub>1</sub> , ... , k<sub>n</sub>: s<sub>n</sub>}</code> we have that <b>j'</b> satisfies <b>s</b></li>
<li><strong>k</strong> is of the form <code>"required": [k<sub>1</sub> , ... , k<sub>n</sub>]</code> and each <b>k<sub>i</sub></b></b> appears in <strong>J</strong>. </li>
<li><strong>k</strong> is of the form <code>"minProperties": n</code> and <b>J</b> is an object with at least <strong>n</strong> key:value pairs</li>
<li><strong>k</strong> is of the form <code>"maxProperties": n</code> and <b>J</b> is an object with at most <strong>n</strong> key:value pairs</li>
<li><strong>k</strong> is of the form <code>"dependencies": {k<sub>1</sub>: [k<sub>1</sub>], ... , k<sub>n</sub>: [k<sub>n</sub>]}</code> and <b>J</b> is an object such that if <strong>k<sub>i</sub></strong> appears on <b>J</b> then every keyword in <strong>[k<sub>i</sub>]</strong> appears in <b>J</b></li>
<li><strong>k</strong> is of the form <code>"dependencies": {k<sub>1</sub>: s<sub>1</sub> , ... , k<sub>n</sub>: s<sub>n</sub>}</code>  and <b>J</b> is an object such that if <b>k<sub>i</sub></b> appears on <b>J</b> then <b>J</b> must satisfy <b>s<sub>i</sub></b></li>
<li><strong>k</strong> is of the form <code>"patternProperties": {regexp<sub>1</sub>: s<sub>1</sub> , ... , regexp<sub>n</sub>: s<sub>n</sub>}</code> and <b>J</b> is an object such that for each key-value pair <b>k': j'</b> in <b>J</b>, if <b>k'</b> is in the language of  regexp<sub>i</sub> for some i in [ <strong>1</strong> , ... , <strong>n</strong> ] then <b>j'</b> satisfies <b>s<sub>i</sub></b></b></li>
<li><strong>k</strong> is of the form <code>"anyOf": [{Sch<sub>1</sub>}, {Sch<sub>2</sub>}, ... ,{Sch<sub>n</sub>}]</code> and <strong>J</strong> validates against <em>some</em> <strong>Sch<sub>i</sub></strong>, for <strong>i</strong>=<strong>1</strong>...<strong>n</strong></li>
<li><strong>k</strong> is of the form <code>"allOf": [{Sch<sub>1</sub>}, {Sch<sub>2</sub>}, ... ,{Sch<sub>n</sub>}]</code> and <strong>J</strong> validates against <em>all</em> of <strong>Sch<sub>i</sub></strong>, for <strong>i</strong>=<strong>1</strong>...<strong>n</strong></li>
<li><strong>k</strong> is of the form <code>"oneOf": [{Sch<sub>1</sub>}, {Sch<sub>2</sub>}, ... ,{Sch<sub>n</sub>}]</code> and <strong>J</strong> validates against <em>exactly one</em> of <strong>Sch<sub>i</sub></strong>, for <strong>i</strong>=<strong>1</strong>...<strong>n</strong></li>
<li><strong>k</strong> is of the form <code>"not": {Sch}</code> and <strong>J</strong> does <em>not</em> validate against <strong>Sch</strong></li>
<li><strong>k</strong> is of the form <code>"enum": [val<sub>1</sub> , ... , val<sub>n]</code> and <strong>J</strong> is any <strong>val<sub>i</sub></strong> for some <strong>i</strong> in [ <strong>1</strong> , ..., <strong>n</strong> ].</li>
</ul>
<h2 id="free-type-schemas">Free Type Schemas</h2>
<p>In this case we may have two kinds of schemas. On one hand, we coud have schemas containing the <code>"type": [t<sub>1</sub> . . . t<sub>n</sub>]</code> restriction. On the other hand, we could have schemas without any <code>"type"</code> restriction on them. </p>
<p>But before specifying the semantics for these validation instances we must define a couple of structures first. Consider the following compatibility table:</p>
<table>
<thead>
<tr>
<th>type</th>
<th>compatible keywords</th>
</tr>
</thead>
<tbody>
<tr>
<td>string</td>
<td>"type", "minLength", "maxLength",  "pattern".</td>
</tr>
<tr>
<td>number</td>
<td>"type", "minimum", "maximum", "exclusiveMinimum", "exclusiveMaximum", "multipleOf".</td>
</tr>
<tr>
<td>integer</td>
<td>"type", "minimum", "maximum", "exclusiveMinimum", "exclusiveMaximum", "multipleOf".</td>
</tr>
<tr>
<td>boolean</td>
<td>"type".</td>
</tr>
<tr>
<td>null</td>
<td>"type".</td>
</tr>
<tr>
<td>array</td>
<td>"type", "minItems", "maxItems", "items", "uniqueItems".</td>
</tr>
<tr>
<td>object</td>
<td>"type", "properties", "additionalProperties", "required", "minProperties", "maxProperties", "dependencies", "patternProperties", "regexp".</td>
</tr>
</tbody>
</table>
<p>We define the function <strong>Compatible(J,k)</strong> that takes a JSON document <strong>J</strong> and a 
key/value pair <strong>k</strong> of the form <code>key: value</code> and returns <strong>true</strong> if <code>key</code> is a string in the following list:</p>
<table>
<thead>
<tr>
<th>list of keywords</th>
</tr>
</thead>
<tbody>
<tr>
<td>"type", "minLength", "maxLength",  "pattern", "minimum", "maximum", "exclusiveMinimum", "exclusiveMaximum", "multipleOf", "minItems", "maxItems", "items", "uniqueItems", "properties", "additionalProperties", "required", "minProperties", "maxProperties", "dependencies", "patternProperties", "regexp".</td>
</tr>
</tbody>
</table>
<p>and <code>key</code> is compatible to the type of <strong>J</strong> according to the compatibility table above. Otherwise, <strong>Compatible(J,k)</strong> returns <strong>false</strong>. </p>
<p>Let <strong>M</strong> be a multiple type Schema and <strong>J</strong> a JSON document. 
We say that <strong>J</strong> validates against <strong>M</strong> if one of the following holds:</p>
<ul>
<li>
<p>for each name/value pair <strong>k</strong> in <strong>M</strong> we have that <strong>Compatible(J,k) = false</strong>  </p>
</li>
<li>
<p>for each name/value pair <strong>k</strong> in <strong>M</strong> such that <strong>Compatible(J,k) = true</strong> and <strong>J</strong> validates against <strong>k</strong>. Here we must note that the semantics of <strong>k</strong> is mentioned in each type section</p>
</li>
</ul>
<p>We may also have a multiple type restriction. In this case we say that <strong>J</strong> validates against <strong>M</strong> if the following holds:</p>
<ul>
<li><strong>M</strong> has the name/value pair <code>"type: [t<sub>1</sub> ... t<sub>n</sub>]"</code> and <strong>J</strong> type is <strong>t<sub>i</sub></strong> for some <strong>t<sub>i</sub></strong> in <strong>[ t<sub>1</sub>  ...  t<sub>n</sub> ]</strong>.</li>
</ul></div>
        </div>

        <footer class="col-md-12">
            <hr>
            
            <center>Documentation built with <a href="http://www.mkdocs.org/">MkDocs</a>.</center>
        </footer>

        <script src="../../js/jquery-1.10.2.min.js"></script>
        <script src="../../js/bootstrap-3.0.3.min.js"></script>
        <script src="../../js/highlight.pack.js"></script>
        <script src="../../js/base.js"></script>
    </body>
</html>