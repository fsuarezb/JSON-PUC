<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        
        <link rel="shortcut icon" href="../../img/favicon.ico">

	<title>Arrays & Objects - JSON Schema</title>

        <link href="../../css/bootstrap-custom.min.css" rel="stylesheet">
        <link href="../../css/font-awesome-4.0.3.css" rel="stylesheet">
        <link rel="stylesheet" href="../../css/highlight.css">
        <link href="../../css/base.css" rel="stylesheet">

        <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
        <![endif]-->

        
    </head>

    <body>

        <div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">

        <!-- Collapsed navigation -->
        <div class="navbar-header">
            <!-- Expander button -->
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>

            <!-- Main title -->
            <a class="navbar-brand" href="../..">JSON Schema</a>
        </div>

        <!-- Expanded navigation -->
        <div class="navbar-collapse collapse">
            <!-- Main navigation -->
            <ul class="nav navbar-nav">
            
            
                <li >
                    <a href="../..">Home</a>
                </li>
            
            
            
                <li class="dropdown active">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">Specification <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li >
                            <a href="../introduction/">Introduction</a>
                        </li>
                    
                        <li >
                            <a href="../basic_types/">Basic Types</a>
                        </li>
                    
                        <li class="active">
                            <a href="./">Arrays & Objects</a>
                        </li>
                    
                        <li >
                            <a href="../combined_schemas/">Combined Schemas</a>
                        </li>
                    
                        <li >
                            <a href="../definitions_references/">Definitions & References</a>
                        </li>
                    
                        <li >
                            <a href="../multiple_types/">Multiple Types</a>
                        </li>
                    
                        <li >
                            <a href="../generic_keywords/">Generic Keywords</a>
                        </li>
                    
                    </ul>
                </li>
            
            
            </ul>

            <!-- Search, Navigation and Repo links -->
            <ul class="nav navbar-nav navbar-right">
                <li >
                    <a rel="next" href="../basic_types/">
                        <i class="fa fa-arrow-left"></i> Previous
                    </a>
                </li>
                <li >
                    <a rel="prev" href="../combined_schemas/">
                        Next <i class="fa fa-arrow-right"></i>
                    </a>
                </li>
                
            </ul>
        </div>
    </div>
</div>

        <div class="container">
            <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
    
        <li class="main active"><a href="#arrays-objects">Arrays &amp; Objects</a></li>
        
            <li><a href="#array-schemas">Array Schemas</a></li>
        
            <li><a href="#object-schemas">Object Schemas</a></li>
        
    
    </ul>
</div></div>
            <div class="col-md-9" role="main">

<h1 id="arrays-objects"><CENTER>Arrays &amp; Objects</CENTER></h1>
<p><center>Here we show how to specify collections of key:value pairs using possibly nested JSON Schemas.</center></p>
<h2 id="array-schemas">Array Schemas</h2>
<p>Arrays are used to represent ordered sets of values, scuh as the following sequence of strings:</p>
<pre><code>["Chilean", "Argentinean", "Peruvian", "Colombian"]</code></pre>

<p>On this section we specify array's main charasteristics and restrictions that may apply to them using a single JSON Schema document.</p>
<p>First of all, we want to ensure that the element that we are validating is efectively an array with the type restriction. This is the basic array schema:</p>
<pre><code>{
 "type": "array"
}</code></pre>

<p>And specifyies arrays. For example
this document does not validate against the schema:</p>
<pre><code>{
 "nation1": "chilean", 
 "nation2": "argentinean",
 "this": "is",
 "not": "an",
 "keyword": "array"
 }</code></pre>

<p>but this one does validate: </p>
<pre><code>
["Chilean", "Argentinean", "this", "is", "an", "array"]</code></pre>

<h3 id="restrictions">Restrictions</h3>
<p>We can restrict the contents of an array using a JSON Schema. For example, if we want to be sure that the items of the array are strings and that we could have at most <code>3</code> items we could use the following schema:</p>
<pre><code>{
 "type": "array",
 "maxItems": 3,
 "items": {
           "type": "string"
          }
}</code></pre>

<p>The following JSON document would validate again the schema:</p>
<pre><code>["Chilean", "Argentinean"]</code></pre>

<p>This one would not validate since it has more than 3 elements:</p>
<pre><code>["Chilean", "Argentinean", "Peruvian", "Colombian"]</code></pre>

<p>A JSON Schema for an array can be seen as set of restrictions that must apply on the elements of the arrays. In the next sections we specificate each restriction and how a JSON document validate against these restrictions.</p>
<h4 id="item-restriction">Item Restriction</h4>
<p>We use these restrictions to restrict the elements of the array. We have two ways of doing this. </p>
<p>The first is to enforce that all the elements of the array must validate against a given schema, as in the following example:</p>
<pre><code>{
 "type": "array",
 "items":{
          "type": "integer"
         }
}</code></pre>

<p>In this case, we are asking that every element of the array must be an integer. For example, this array validates valid against the schema</p>
<pre><code>[3, 1, 4, 5]</code></pre>

<p>But this one does not</p>
<pre><code>[3, "one", 4, 5]</code></pre>

<p>The second way of restricting the elements is to specify a JSON Schema for each element in the array. The following schema is an example of the second use of the items restriction: </p>
<pre><code>{
 "type": "array",
 "items" : [{
          "type": "string"
         },
         {
          "type": "integer"
         },
         {
          "type": "boolean"
         }
         ]
}</code></pre>

<p>In this case, we are asking that the first element must be a string, the second one an integer and the third one a boolean. For example, this array validates against the schema</p>
<pre><code>["Chile", 1, true ]</code></pre>

<p>But this one does not</p>
<pre><code>["Chile", "one", 4]</code></pre>

<h4 id="additional-items">Additional Items</h4>
<p>This restriction specifies if the array can contain items which are not specified on the schema. Here we have an example of this kind of restriction</p>
<pre><code>{
 "type": "array",
 "items" : [{
          "type": "string"
         },
         {
          "type": "integer"
         },
         {
          "type": "boolean"
         }
         ],
 "additionalItems": false       
}</code></pre>

<p>In this example, we are asking that the first element must be a string, the second one an integer and the third one a boolean. But we cannot have any more items than these three. Here have JSON document that validates against this schema</p>
<pre><code>["Chile", 1, true]</code></pre>

<p>But this one does not validate, because there is an additional item. </p>
<pre><code>["Chile", 1, true, 2]</code></pre>

<h4 id="item-quantity">Item Quantity</h4>
<p>We can also specify an interval on the amount of items of an array. We use <code>"minItems": n</code> to specify that the array must have at least <code>n</code> elements, and <code>"maxItems":  n</code> to specify that the array cannot have more than <code>n</code> elements. Here we have an example of this restriction</p>
<pre><code>{
 "type": "array",
 "minItems": 2,
 "maxItems": 5
}</code></pre>

<p>As we can see, we are specifying arrays with at least <code>2</code> elements and no more than <code>5</code>. For example this document validates against the schema</p>
<pre><code>["Chile", 16.000.000, "San Francisco", 800.000]</code></pre>

<p>But this one does not</p>
<pre><code>["Chile", 16.000.000, "San Francisco", 800.000, "London", 9.000.000]</code></pre>

<h4 id="uniqueness">Uniqueness</h4>
<p>We use this restriction if we want all elements of an array to be different. The following schema specifies an array in which all documents are different:</p>
<pre><code>{
 "type": "array",
 "uniqueItems": true
}</code></pre>

<p>For example this document validates against the schema</p>
<pre><code>[1, 3, 5, 7]</code></pre>

<p>But this one does not, </p>
<pre><code>[1, 3, 5, 3]</code></pre>

<h3 id="formal-specification">Formal Specification</h3>
<p>The correct grammar for these schemmas is as follows:
<pre>
 <b>arrSch</b>:= "type": "array" (, <b>arrRes</b>)<sup>*</sup>
</pre></p>
<p>Here <strong>arrRes</strong> is a restriction for the type array such that every <strong>arrRes</strong> must be different from each other and occurs no more than one time each. Each of these restrictions is defined as follows:</p>
<pre>
 <b>arrRes</b> := <b>items</b> | <b>additems</b> | <b>minitems</b> | <b>maxitems</b>  | <b>unique</b>
 <b>items</b> := ( <b>sameitems</b> |  <b>varitems</b> )
 <b>sameitems</b> := "items": { <b>JSch</b> }
 <b>varitems</b> := "items": [{ <b>JSch</b> }(,{ <b>JSch</b> })<sup>*</sup>] (, "additionalItems": false)?
 <b>minitems</b> := "minItems: " n
 <b>maxitems</b> := "maxItems: " n
 <b>unique</b> := "uniqueItems: " (true | false)
</pre>

<p>Here <strong>n</strong> is a natural number and <b>JSch</b> a JSON Schema. Note that we do not include <code>"additionalItems": true</code> in <strong>varitems</strong>, since it is the default. </p>
<h3 id="formal-validation">Formal Validation</h3>
<p>Let <b>A</b> be an Array Schema and <b>J</b> a JSON document. We say that <b>J</b> validates against <b>A</b> if for each key:value pair <b>k</b> in <b>A</b> one of the following holds:</p>
<ul>
<li><b>k</b> is <code>"type": "array"</code> and <b>J</b> is an array</li>
<li><b>k</b> is <code>"items": s</code> and <b>J</b> is an array such that every element validates against <strong>s</strong></li>
<li><b>k</b> is <code>"items": [s<sub>1</sub> , ... , s<sub>n</sub>]</code> and <b>J</b> is an array <code>[a<sub>1</sub> , ... , a<sub>m</sub>]</code> such that every element <strong>a<sub>i</sub></strong> validates against <strong>s<sub>i</sub></strong> with <strong>i</strong> â‰¤ Min(<strong>m</strong>,<strong>n</strong>).</li>
<li><b>k</b> is <code>"additionalItems": false</code>, there is a key:value pair <code>"items": [s<sub>1</sub> , ... , s<sub>n</sub>]</code> in <strong>A</strong> and <strong>J</strong> is an array with at most n elements. </li>
<li><b>k</b> is <code>"minItems": n</code> and <b>J</b> is an array with at least n elements</li>
<li><b>k</b> is <code>"maxItems": n</code> and <b>J</b> is an array with at most n elements</li>
<li><b>k</b> is <code>"uniqueItems": true</code> and <b>J</b> is an array with all elements different from each other</li>
</ul>
<h2 id="object-schemas">Object Schemas</h2>
<p>Objects in JSON are collections of key:value pairs, where the values in these pairs can be again any JSON Document. 
JSON schemas that specify objects are called <em>Object Schemas</em>. The document</p>
<pre><code>{"type": "object"}</code></pre>

<p>is an Object Schema. It specifies any JSON document that is an object, such as </p>
<pre><code>{
  "first_name": "Gary", 
  "last_name": "Medel"
}</code></pre>

<p>or </p>
<pre><code>{
  "name": {"first": "Gary", "last": "Medel"}, 
  "age": 27
}</code></pre>

<p>but not </p>
<pre><code>["this","list","is","ordered"]</code></pre>

<h3 id="restrictions_1">Restrictions</h3>
<p>Using JSON Schema we have several keywords to specify more specific types of objects. For example, if we want to specify documents that include <code>first_name</code>, <code>last_name</code> and <code>age</code>, we use</p>
<pre><code>{
    "type": "object",
    "required": ["first_name", "last_name", "age"]
}</code></pre>

<p>Object types that validate against this schema must have at least pairs with keys <code>first_name</code>, 
<code>last_name</code> and <code>age</code>. </p>
<p>However, we have not stated any restrictions for the values of these pairs. This means that the following document also validates against the previous schema: </p>
<pre><code>{
    "first_name": 4,
    "last_name": true,
    "age": "whatever"
}</code></pre>

<p>Not very informative, right? Ideally we would like the values of <code>first_name</code> and <code>last_name</code> be strings and <code>age</code> be an integer. We do it as follows: </p>
<pre><code>{
    "type": "object",
    "required": ["first_name", "last_name", "age"],
    "properties": {
        "first_name": {"type": "string"},
        "last_name": {"type": "string"},
        "age": {"type": "integer"}
    }
}</code></pre>

<p>This time, the only documents that validate against the schema are those that looke like this one:</p>
<pre><code>{
    "first_name": "Gary",
    "last_name": "Medel",
    "age": 27
}</code></pre>

<p>Next we review all restrictions avaliable for Object Schemas. </p>
<h4 id="required">Required</h4>
<p>As we have mentioned, we use <code>"required"</code> to specify a list of strings that need to be present as the name of the pairs of the documents. In general, a schema of the form </p>
<pre><code>{
    "type": "object",
    "required": ["a", "b", "c", "d"]
}</code></pre>

<p>Specifies documents that need to have pairs with names <code>"a"</code>, <code>"b"</code>, <code>"c"</code> and <code>"d"</code>. </p>
<h4 id="properties">Properties</h4>
<p>The <code>property</code> keyword is used to specify the key:value pairs of JSON documents. The value of <code>property</code> is itself a key:value pair: the value can be any JSON schema, it is used to specify how the value of the key:value pair should look. For example, the following schema specifies that objects should have at least two pairs, with keys <code>first</code> and <code>last</code>, and the values of those must be strings. </p>
<pre><code>{
    "type": "object",
    "required": ["first", "last"],
    "properties": {
        "first": {"type": "string"},
        "last": {"type": "string"}
    }
}</code></pre>

<p>Now lets say we want to specify football players. They should have a <code>name</code>, <code>age</code> and a <code>club_name</code>, and the <code>name</code> should consist of a <code>first name</code> and a <code>last name</code>. We do it with the following schema: </p>
<p><pre><code>{
    "type": "object",
    "required": ["name", "age","club_name"],
    "properties": {
           "name": {
               "type": "object",
               "required": ["first", "last"]
               "properties": {
                       "first": {"type": "string"},
                       "last": {"type": "string"}
               }
           },
           "age": {"type": "integer"}, 
           "club_name": {"type": "string"}
    }
}</code></pre></p>
<p>Note that the schema under <code>"name"</code> is again another Object Schema. We can do this as many times as we want! The following document validates against this schema</p>
<pre><code>
{
   "name": {
      "first_name": "Gary",
      "last_name": "Medel"
   },
   "age": 27,
   "club_name": "Inter de Milan"
}</code></pre>

<p>By default the names specified under <code>"properties"</code> are not required, this means that, for example, the empty document </p>
<pre><code>{}</code></pre>

<p>validates against the schema </p>
<pre><code>{
    "type": "object",
    "properties": {
        "first": {"type": "string"},
        "last": {"type": "string"}
    }
}</code></pre>

<p>For validation purproses the <code>"properties"</code> keyword should be understood as follows: if a document has a key:value pair <em>and</em> the key of the pair is specified in <code>"properties"</code>, then the value of the pair needs to validate against the schema specified under the key in <code>"properties"</code>. </p>
<h4 id="additional-properties">Additional Properties</h4>
<p>The restriction <code>"properties"</code> does not state aything about the structure of any additional names not specified in this keyword. The <code>"additionalProperties"</code> keyword is used both to state if the document will support additional properties from the ones named on <code>"properties"</code> restriction and to give an schema for these extra properties. For example, lets analyze the following schema </p>
<pre><code>{
    "type": "object",
    "properties": {
        "first": {"type": "string"},
        "last": {"type": "string"}
    },
    "additionalProperties": false
}</code></pre>

<p>In this case we are asking for documents that don't have any properties whose keywords are different from <code>"first"</code> and <code>"last"</code>. For instance, this document would not validate:</p>
<pre><code>{
    "first": "Gary",
    "last": "Medel",
    "age": 25
}</code></pre>

<p>The other use of <code>"additionalProperties"</code> is to restrict the structure of the additional properties in the object. For example, the consider the following schema </p>
<pre><code>{
    "type": "object",
    "properties": {
        "first": {"type": "string"},
        "last": {"type": "string"}
    },
    "additionalProperties": {
                             "type": "integer"
                            }
}</code></pre>

<p>Here we are asking that any keywords different from <code>"first"</code> and <code>"last"</code> must have integer values. For example the next JSON document validates against the schema</p>
<pre><code>{
    "first": "Gary",
    "last": "Medel",
    "age": 25
}</code></pre>

<p>But this one doesn't</p>
<pre><code>{
    "first": "Gary",
    "last": "Medel",
    "age": "twenty five"
}</code></pre>

<h4 id="number-of-properties">Number of Properties</h4>
<p>The <code>"minProperties"</code>and <code>"maxProperties"</code> keywords are used to restrict the number of properties allowed on a JSON object. For example, lets consider the following schema </p>
<pre><code>{
    "type": "object",
    "minProperties": 3,
    "maxProperties": 5
}</code></pre>

<p>Here we are asking for JSON objects with at least <code>3</code> properties and no more than <code>5</code>. For example this object validates against the previous schema</p>
<pre><code>{
    "first": 10,
    "second": 11,
    "third": 12,
    "four": 13
}</code></pre>

<p>but this one doesn't</p>
<pre><code>{
    "first": 10,
    "second": 11
}</code></pre>

<h4 id="dependencies">Dependencies</h4>
<p>Dependecies are used to modify the schema in function of the key:value pairs that are present in the JSON document. There is two ways of doing this with the<code>"dependencies"</code> keyword. </p>
<p>The first way is to force the presence of some properties whenever a particular key is present in the document. Let's consider the following example</p>
<pre><code>{
    "type": "object",
    "properties": {
        "first": {"type": "string"},
        "last": {"type": "string"},
        "team": {"type": "string"},
        "league": {"type": "string"}
            },
    "required": ["first", "last"],
    "dependencies":{
                        "team": ["league"]    
                      }
}</code></pre>

<p>Here we validate all documents that contain the keys <code>"first"</code> and <code>"last"</code>, but if the object has the key <code>"team"</code> then the key <code>"league"</code> becomes a required property. For example, this document is valid against the schema</p>
<pre><code>{
    "first": "Gary",
    "second": "Medel",
    "team": "Inter Milan",
    "league": "Serie A"
}</code></pre>

<p>but this one is not valid</p>
<pre><code>{
    "first": "Gary",
    "second": "Medel",
    "team": "Inter Milan"
}</code></pre>

<p>The other way of using the <code>"dependencies"</code> keyword is to specify that the JSON object must also satisfy another JSON Schema whenever certain keys are present. Lets consider the following schema as an example</p>
<pre><code>{
    "type": "object",
    "properties": {
        "first": {"type": "string"},
        "last": {"type": "string"},
        "team": {"type": "string"}
            },
    "required": ["first", "last"],
    "dependencies":{
                        "team": {
                        "type": "object",
                        "properties": {
                            "league": {"type": "string"},
                            "goals": {"type": "integer"}
                                         },
                       "required": ["league", "goals"]
                        }  
                      }
}</code></pre>

<p>Now JSON object that do have the key <code>"team"</code> must also validate against the schema </p>
<pre>
{
    "type": "object",
    "properties": {
        "league": {"type": "string"},
        "goals": {"type": "integer"}
        },
    "required": ["league", "goals"]
}
</pre>

<p>and thus it must also have the keys <code>"league"</code> and <code>"goals"</code>. For example the next two objects validate against the complete schema</p>
<pre><code>{
    "first": "Gary",
    "second": "Medel",
}</code></pre>

<pre><code>{
    "first": "Gary",
    "second": "Medel",
    "team": "Inter Milan",
    "league": "Serie A",
    "goals": 5
}</code></pre>

<p>But this one doesn't</p>
<pre><code>{
    "first": "Gary",
    "second": "Medel",
    "team": "Inter Milan",
    "goals": 5
}</code></pre>

<h4 id="pattern-properties">Pattern Properties</h4>
<p>Sometimes we want to restrict a set of properties depending if they share a pattern on they keys. The <code>"patternProperties"</code> keyword is used to restrict keywords matching to a certain regular expression. Let's see an example of this</p>
<pre><code>{
    "type": "object",
    "properties": {
        "first": {"type": "string"},
        "last": {"type": "string"},
        "team": {"type": "string"},
        "league": {"type": "string"}
            },
   "patternProperties": {
       "_goals$": { "type": "integer" }
  }
}</code></pre>

<p>Here we are asking that keys matching the regular expression  <code>_goals$</code> must be integers. For example the following JSON object validates against the schema</p>
<pre><code>{
    "first": "Gary",
    "second": "Medel",
    "team": "Inter de Milan",
    "league": "Serie A",
    "league_goals": 5,
    "international_goals": 2
}</code></pre>

<p>but this one doesn't</p>
<pre><code>{
    "first": "Gary",
    "second": "Medel",
    "team": "Inter de Milan",
    "league": "Serie A",
    "league_goals": "five"
}</code></pre>

<h3 id="formal-specification_1">Formal Specification</h3>
<p>The correct grammar for these schemmas can be seen like this:</p>
<pre>
 <b>objSch</b>:= "type": "object" (, <b>objRes</b>)<sup>*</sup>
</pre>

<p>Here <strong>objRes</strong> is a restriction for objects such that every <strong>objRes</strong> must be different from each other in the schema and occurs no more than one time each. Each of these restrictions is defined as follows:</p>
<pre>
 <b>arrRes</b> := <b>typeObj</b> | <b>prop</b> | <b>addprop</b> | <b>req</b> | <b>minprop</b> | <b>maxprop</b> | <b>dep</b>| <b>pattprop</b>
 <b>prop</b> := "properties: "{ <b>kSch</b> (, <b>kSch</b>)<sup>*</sup>}
 <b>addprop</b> := "additionalProperties": (true | false | { <b>JSch</b> })
 <b>req</b> := "required": [ <b>kword</b> (, <b>kword</b>)<sup>*</sup>]
 <b>minprop</b> := "minProperties: " n
 <b>maxprop</b> := "maxProperties: " n
 <b>dep</b> := "dependencies: "(<b>depArr</b> | <b>depSch</b>)
 <b>depArr</b> := { <b>kArr</b> (, <b>kArr</b>)<sup>*</sup>}
 <b>depSch</b> := { <b>kSch</b> (, <b>kSch</b>)<sup>*</sup>}
 <b>kArr</b> := <b>kword</b>: [ <b>kword</b> (, <b>kword</b>)<sup>*</sup>]
<b> kSch </b> := <b>kword</b>: {<b>JSch</b>}
 <b>pattprop</b> := "patternProperties: "{ <b>patSch</b> (, <b>patSch</b>)<sup>*</sup>}
 <b>patSch</b> := regexp: { <b>JSch</b> } </pre>

<p>Here <strong>n</strong> is a natural number, <b>kword</b> is a JSON string and <b>JSch</b> a JSON Schema. </p>
<h3 id="formal-validation_1">Formal Validation</h3>
<p>Let <b>O</b> be an object Schema and <b>J</b> a JSON document. We say that a keyword <strong>k</strong> appears in <strong>J</strong> is <strong>J</strong> contains a key:value pair of the form <strong>k: j'</strong>, for some document <strong>j'</strong>. </p>
<p>We say that <b>J</b> validates against <b>O</b> if for each key:value pair <b>k</b> in <b>O</b> one of the following holds:</p>
<ul>
<li><b>k</b> is <code>"type": "object"</code> and <b>J</b> is an object</li>
<li><b>k</b> is <code>"properties": {k<sub>1</sub>: s<sub>1</sub> , ... , k<sub>n</sub>: s<sub>n</sub>}</code> and <b>J</b> is an object that for each key-value pair <b>k': j'</b> in <b>J</b>, if <b>k' = k<sub>i</sub></b> for some <strong>i</strong> in [ <strong>1</strong> , ... , <strong>n</strong> ] then <b>j'</b> satisfies <b>s<sub>i</sub></b></b></li>
<li><b>k</b> is <code>"additionalProperties": false</code> and <b>J</b> is an object such that every keyword in <b>J</b> is mentioned in <code>"properties": {k<sub>1</sub>: s<sub>1</sub> , ... , k<sub>n</sub>: s<sub>n</sub>}</code></li>
<li><b>k</b> is <code>"additionalProperties": true</code> and <b>J</b> is an object</li>
<li><b>k</b> is <code>"additionalProperties": s</code> and <b>J</b> is an object that for each key-value pair <b>k': j'</b> in <b>J</b> such that <b>k'</b> is different from every <b>k<sub>i</sub></b></b> in <code>"properties": {k<sub>1</sub>: s<sub>1</sub> , ... , k<sub>n</sub>: s<sub>n</sub>}</code> we have that <b>j'</b> satisfies <b>s</b></li>
<li><b>k</b> is <code>"required": [k<sub>1</sub> , ... , k<sub>n</sub>]</code> and each <b>k<sub>i</sub></b></b> appears in <strong>J</strong>. </li>
<li><b>k</b> is <code>"minProperties": n</code> and <b>J</b> is an object with at least <strong>n</strong> key:value pairs</li>
<li><b>k</b> is <code>"maxProperties": n</code> and <b>J</b> is an object with at most <strong>n</strong> key:value pairs</li>
<li><b>k</b> is <code>"dependencies": {k<sub>1</sub>: [k<sub>1</sub>], ... , k<sub>n</sub>: [k<sub>n</sub>]}</code> and <b>J</b> is an object such that if <strong>k<sub>i</sub></strong> appears on <b>J</b> then every keyword in <strong>[k<sub>i</sub>]</strong> appears in <b>J</b></li>
<li><b>k</b> is <code>"dependencies": {k<sub>1</sub>: s<sub>1</sub> , ... , k<sub>n</sub>: s<sub>n</sub>}</code>  and <b>J</b> is an object such that if <b>k<sub>i</sub></b> appears on <b>J</b> then <b>J</b> must satisfy <b>s<sub>i</sub></b></li>
<li><b>k</b> is <code>"patternProperties": {regexp<sub>1</sub>: s<sub>1</sub> , ... , regexp<sub>n</sub>: s<sub>n</sub>}</code> and <b>J</b> is an object such that for each key-value pair <b>k': j'</b> in <b>J</b>, if <b>k'</b> is in the language of  regexp<sub>i</sub> for some i in [ <strong>1</strong> , ... , <strong>n</strong> ] then <b>j'</b> satisfies <b>s<sub>i</sub></b></b></li>
</ul></div>
        </div>

        <footer class="col-md-12">
            <hr>
            
            <center>Documentation built with <a href="http://www.mkdocs.org/">MkDocs</a>.</center>
        </footer>

        <script src="../../js/jquery-1.10.2.min.js"></script>
        <script src="../../js/bootstrap-3.0.3.min.js"></script>
        <script src="../../js/highlight.pack.js"></script>
        <script src="../../js/base.js"></script>
    </body>
</html>