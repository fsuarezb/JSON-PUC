{
    "docs": [
        {
            "location": "/", 
            "text": "HOME\n\n\nHere you'll find some general information about this site JSON Schema\n\n\nAbout this site\n\n\nThis site is intended to be a complete and understandable guide to \nJSON Schema\n. You can find an exhaustive specification with intuitive examples. The people behind this project form part of the \nComputer Science Department\n of \nPUC Chile\n, and belong to the \nCenter for Semantic Web Research\n.\n\n\n\n\nWhat is JSON?\n\n\nJSON\n (JavaScript Object Notation) is a file format commonly used for sharing information over the Web. JSON files are lightweight and easy to read by both machines and developers. This has made JSON the most popular file format for client-server communication. The next example JSON file contains information about the famous Chilean football player Gary Medel.\n\n\ngary_medel.json\n\n\n{\n    \nfirst_name\n: \nGary\n,\n    \nlast_name\n: \nMedel\n,\n    \nage\n: 27,\n    \nclub\n: {\n        \nname\n: \nInter Milan\n,\n        \nfounded\n: 1908\n    } \n}\n\n\n\n\n\n\nWhat is JSON Schema?\n\n\nA JSON Schema is a file that specifies the structure of the JSON files used for a certain application. For example, when sharing information about football players, one would like to ensure the JSON file corresponding to a player has a given structure. A JSON Schema is a JSON file in which some words (keywords) have a predefined meaning. The next example specifies documents like \ngary_mede.json\n.\n\n\nplayer_schema.json\n\n\n{\n    \ntype\n: \nobject\n,\n    \nproperties\n: {\n        \nfirst_name\n: { \ntype\n: \nstring\n },\n        \nlast_name\n: { \ntype\n: \nstring\n },\n        \nage\n: { \ntype\n: \ninteger\n },\n        \nclub\n: {\n            \ntype\n: \nobject\n,\n            \nproperties\n: {\n                \nname\n: { \ntype\n: \nstring\n },\n                \nfounded\n: { \ntype\n: \ninteger\n }\n            },\n            \nrequired\n: [\nname\n]\n        }\n    },\n    \nrequired\n: [\nfirst_name\n, \nlast_name\n, \nage\n, \nclub\n]\n}\n\n\n\n\n\n\nWhy to use JSON Schema\n\n\nThere are several reasons to use a schema when storing data or sharing data over the Web. Some of the benefits:\n\n\n\n\nFiltering content: when storing files or receiving files over the web, one always want to make sure the data comes in the right format. JSON Schema allows for on-the-fly validation of JSON files.\n\n\nCompression: if a schema is known by both the source and the target when sharing information, the network load can be decreased by compressing the name of the properties.\n\n\nStandardization: Today many APIs receive JSON files as instructions. For example, you can send a JSON file to Twitter's API indicating you want the last five tweets of a user. To use one of these APIs, you need to read the documentation provided by the API developers. Sometimes this documentation is messy and hard to read. If APIs defined a JSON Schema for input files, one could easily understand the allowed JSON files. Moreover, this allows for creating automation tools. For example, given a JSON Schema one could automatically generate a set of example API calls.", 
            "title": "Home"
        }, 
        {
            "location": "/#about-this-site", 
            "text": "This site is intended to be a complete and understandable guide to  JSON Schema . You can find an exhaustive specification with intuitive examples. The people behind this project form part of the  Computer Science Department  of  PUC Chile , and belong to the  Center for Semantic Web Research .", 
            "title": "About this site"
        }, 
        {
            "location": "/#what-is-json", 
            "text": "JSON  (JavaScript Object Notation) is a file format commonly used for sharing information over the Web. JSON files are lightweight and easy to read by both machines and developers. This has made JSON the most popular file format for client-server communication. The next example JSON file contains information about the famous Chilean football player Gary Medel.  gary_medel.json  {\n     first_name :  Gary ,\n     last_name :  Medel ,\n     age : 27,\n     club : {\n         name :  Inter Milan ,\n         founded : 1908\n    } \n}", 
            "title": "What is JSON?"
        }, 
        {
            "location": "/#what-is-json-schema", 
            "text": "A JSON Schema is a file that specifies the structure of the JSON files used for a certain application. For example, when sharing information about football players, one would like to ensure the JSON file corresponding to a player has a given structure. A JSON Schema is a JSON file in which some words (keywords) have a predefined meaning. The next example specifies documents like  gary_mede.json .  player_schema.json  {\n     type :  object ,\n     properties : {\n         first_name : {  type :  string  },\n         last_name : {  type :  string  },\n         age : {  type :  integer  },\n         club : {\n             type :  object ,\n             properties : {\n                 name : {  type :  string  },\n                 founded : {  type :  integer  }\n            },\n             required : [ name ]\n        }\n    },\n     required : [ first_name ,  last_name ,  age ,  club ]\n}", 
            "title": "What is JSON Schema?"
        }, 
        {
            "location": "/#why-to-use-json-schema", 
            "text": "There are several reasons to use a schema when storing data or sharing data over the Web. Some of the benefits:   Filtering content: when storing files or receiving files over the web, one always want to make sure the data comes in the right format. JSON Schema allows for on-the-fly validation of JSON files.  Compression: if a schema is known by both the source and the target when sharing information, the network load can be decreased by compressing the name of the properties.  Standardization: Today many APIs receive JSON files as instructions. For example, you can send a JSON file to Twitter's API indicating you want the last five tweets of a user. To use one of these APIs, you need to read the documentation provided by the API developers. Sometimes this documentation is messy and hard to read. If APIs defined a JSON Schema for input files, one could easily understand the allowed JSON files. Moreover, this allows for creating automation tools. For example, given a JSON Schema one could automatically generate a set of example API calls.", 
            "title": "Why to use JSON Schema"
        }, 
        {
            "location": "/spec/introduction/", 
            "text": "Introduction\n\n\nThe basic concepts needed before diving into the world of JSON Schema\n\n\nHere we present a brief description of some concepts that will make the reading of the specification easier. The \nfirst section\n explains what a JSON document is, which is essential to understand the definition of JSON Schemas and how they work. The \nsecond section\n contains a simple explanation of what a JSON Schema is together with a small example, which is explained in detail. Finally, in the \nthird section\n we present some notation that is used throughout the specification to avoid ambiguities.\n\n\nJSON\n\n\nJSON\n (JavaScript Object Notation) is a file format commonly used for sharing information over the Web. JSON files are lightweight and easy to ready by both machines and developers. This has made JSON the most popular file format for client-server communication. A JSON instance is one of the next seven elements:\n\n\n\n\n\n\nstring\n A string is a sequence of valid characters between quotes. For example, \n\"Hello!\"\n is a string, but \n23\n isn't.\n\n\n\n\n\n\nnumber\n A number is created using \nJSON notation\n. For example \n-2\n, \n23\n, \n3.14\n and \n2.54e3\n are all numbers in JSON. \n\n\n\n\n\n\ninteger\n An integers is a JSON number without a fractional part. For example, \n34\n and \n-91\n are integers.\n\n\n\n\n\n\nboolean\n A boolean JSON object is one of two values: \ntrue\n or \nfalse\n.\n\n\n\n\n\n\nnull\n A null object in JSON is the value \nnull\n.\n\n\n\n\n\n\narray\n A JSON array is an ordered sequence of JSON documents separated by comma and enclosed by brackets. For example, \n[\"Hello\", 23, true, null]\n is a JSON array, as well as \n[-2, -1, 3.14, 1.62e10]\n.\n\n\n\n\n\n\nobject\n A JSON object is a set of pairs of the form \nkey:value\n, where \nkey\n is a JSON string and \nvalue\n is a JSON document. These pairs are separated by comma and enclosed by braces. JSON objects are the most common JSON documents. The next is an example of a JSON object that contains information about products of a store:\n\n\n\n\n\n\nproducts.json\n\n\n[\n    {\nid\n: 1,\n     \nname\n: \nMilk\n,\n     \nstock\n: 25},\n    {\nid\n: 2,\n     \nname\n: \nYougurt\n,\n     \nstock\n: 15,\n     \nlink\n: \nhttp://delicious-yougurt.com\n}\n]\n\n\n\n\nJSON Schema\n\n\nA JSON Schema is a file that specifies the structure of the \nJSON documents\n that are used in a certain application. For example, owners of a store might want to share documents with the information of products. Here, a JSON Schema could specify that each of such documents is a list of products, and that each product contains an \nid\n, a \nname\n, a \nstock\n and optionally a \nlink\n to the manufacturer's website. Since it is very simple to verify if a JSON document is \napproved\n by a schema,\nusing a schema would be useful to ensure that all shared documents have this structure. The next JSON Schema specifies the structure defined above:\n\n\nproduct_list_schema.json\n\n\n{  \n    \ntype\n: \narray\n,\n    \nitems\n: {\n        \ntype\n: \nobject\n,\n        \nproperties\n: {\n            \nid\n: {\ntype\n: \ninteger\n},\n            \nname\n: {\ntype\n: \nstring\n},\n            \nstock\n: {\ntype\n: \ninteger\n},\n            \nlink\n: {\ntype\n: \nstring\n},\n        },\n        \nrequired\n: [\nid\n, \nname\n, \nstock\n],\n        \nadditionalProperties\n: false\n    }\n}\n\n\n\n\nFirst, \n\"type\": \"array\"\n indicates that the document must be an array. Then, \n\"items\": {...}\n tells us that each of the array's items must satisfy what's specified in the braces (which is also a schema). Hence, \n\"type\": \"object\"\n indicates that each item of the array must be an object, and \n\"properties\": {...}\n indicates what should be satisfied (also a schema) by the properties of each product. Finally, \n\"required\": [\"id\", \"name\", \"stock\"]\n specifies that each product must have an \nid\n, a \nname\n and a \nstock\n, and \n\"additionalProperties\": false\n says that a product cannot have properties that are not mentioned in \n\"properties\": {...}\n (and hence the only optional property is \nlink\n).\n\n\nNote that the file \nproducts.json\n is \ncorrect\n according to what is specified in \nproduct_list_schema.json\n, and therefore it is a valid document for the application of sending product's information.\n\n\nNotation\n\n\n\n\nJSON Document\n: A document containing a JSON instance in it's content.\n\n\nJSON Schema Document\n: A document containing a JSON Schema instance in addition to a set of JSON Schema instance definitions in it's content.\n\n\nJSON Schema\n: A JSON Schema instance. Note that these kind of instances don't include definitions on their structure.\n\n\nkey-value pair\n: A key-value pair represents an assigment from a particular keyword to a JSON instance.\n\n\nrestriction\n: A single condition that a JSON instance must satisfy. A JSON Schema can be seen as a set of restrictions.\n\n\n\nWhere to go from here\n\n\nYou can visit our \nUser Guide\n for a quick reference on how to create JSON Schemas. If you want to understand in detail how a keyword is validated, please go to the corresponding section of the specification. The specification is intended to be exhaustive and should contain the information needed to write your own JSON Schema validator (if this is not the case please open an issue).", 
            "title": "Introduction"
        }, 
        {
            "location": "/spec/introduction/#introduction", 
            "text": "The basic concepts needed before diving into the world of JSON Schema  Here we present a brief description of some concepts that will make the reading of the specification easier. The  first section  explains what a JSON document is, which is essential to understand the definition of JSON Schemas and how they work. The  second section  contains a simple explanation of what a JSON Schema is together with a small example, which is explained in detail. Finally, in the  third section  we present some notation that is used throughout the specification to avoid ambiguities.", 
            "title": "Introduction"
        }, 
        {
            "location": "/spec/introduction/#json", 
            "text": "JSON  (JavaScript Object Notation) is a file format commonly used for sharing information over the Web. JSON files are lightweight and easy to ready by both machines and developers. This has made JSON the most popular file format for client-server communication. A JSON instance is one of the next seven elements:    string  A string is a sequence of valid characters between quotes. For example,  \"Hello!\"  is a string, but  23  isn't.    number  A number is created using  JSON notation . For example  -2 ,  23 ,  3.14  and  2.54e3  are all numbers in JSON.     integer  An integers is a JSON number without a fractional part. For example,  34  and  -91  are integers.    boolean  A boolean JSON object is one of two values:  true  or  false .    null  A null object in JSON is the value  null .    array  A JSON array is an ordered sequence of JSON documents separated by comma and enclosed by brackets. For example,  [\"Hello\", 23, true, null]  is a JSON array, as well as  [-2, -1, 3.14, 1.62e10] .    object  A JSON object is a set of pairs of the form  key:value , where  key  is a JSON string and  value  is a JSON document. These pairs are separated by comma and enclosed by braces. JSON objects are the most common JSON documents. The next is an example of a JSON object that contains information about products of a store:    products.json  [\n    { id : 1,\n      name :  Milk ,\n      stock : 25},\n    { id : 2,\n      name :  Yougurt ,\n      stock : 15,\n      link :  http://delicious-yougurt.com }\n]", 
            "title": "JSON"
        }, 
        {
            "location": "/spec/introduction/#json-schema", 
            "text": "A JSON Schema is a file that specifies the structure of the  JSON documents  that are used in a certain application. For example, owners of a store might want to share documents with the information of products. Here, a JSON Schema could specify that each of such documents is a list of products, and that each product contains an  id , a  name , a  stock  and optionally a  link  to the manufacturer's website. Since it is very simple to verify if a JSON document is  approved  by a schema,\nusing a schema would be useful to ensure that all shared documents have this structure. The next JSON Schema specifies the structure defined above:  product_list_schema.json  {  \n     type :  array ,\n     items : {\n         type :  object ,\n         properties : {\n             id : { type :  integer },\n             name : { type :  string },\n             stock : { type :  integer },\n             link : { type :  string },\n        },\n         required : [ id ,  name ,  stock ],\n         additionalProperties : false\n    }\n}  First,  \"type\": \"array\"  indicates that the document must be an array. Then,  \"items\": {...}  tells us that each of the array's items must satisfy what's specified in the braces (which is also a schema). Hence,  \"type\": \"object\"  indicates that each item of the array must be an object, and  \"properties\": {...}  indicates what should be satisfied (also a schema) by the properties of each product. Finally,  \"required\": [\"id\", \"name\", \"stock\"]  specifies that each product must have an  id , a  name  and a  stock , and  \"additionalProperties\": false  says that a product cannot have properties that are not mentioned in  \"properties\": {...}  (and hence the only optional property is  link ).  Note that the file  products.json  is  correct  according to what is specified in  product_list_schema.json , and therefore it is a valid document for the application of sending product's information.", 
            "title": "JSON Schema"
        }, 
        {
            "location": "/spec/introduction/#notation", 
            "text": "JSON Document : A document containing a JSON instance in it's content.  JSON Schema Document : A document containing a JSON Schema instance in addition to a set of JSON Schema instance definitions in it's content.  JSON Schema : A JSON Schema instance. Note that these kind of instances don't include definitions on their structure.  key-value pair : A key-value pair represents an assigment from a particular keyword to a JSON instance.  restriction : A single condition that a JSON instance must satisfy. A JSON Schema can be seen as a set of restrictions.", 
            "title": "Notation"
        }, 
        {
            "location": "/spec/introduction/#where-to-go-from-here", 
            "text": "You can visit our  User Guide  for a quick reference on how to create JSON Schemas. If you want to understand in detail how a keyword is validated, please go to the corresponding section of the specification. The specification is intended to be exhaustive and should contain the information needed to write your own JSON Schema validator (if this is not the case please open an issue).", 
            "title": "Where to go from here"
        }, 
        {
            "location": "/spec/basic_types/", 
            "text": "Basic Types\n\n\nJSON Documents can be either values or ordered or unordered list of name/value pairs. We can use JSON Schema to specify that documents can be any of these. For now we concentrate on the specification for values. There are five basic value types supported by JSON Schema: \n\n\nstring\n \nnumber\n  \ninteger\n \nboolean\n \nnull\n\n\nString Schemas\n\n\nOne of the most basic forms of values that appear in JSON documents are strings of text. In JSON schema we can specify that a document is a string by using the keyword \nstring\n as the value of the name \ntype\n. That is, the document\n\n\n{\"type\": \"string\"}\n\n\n\nis a JSON Schema that valiadates against any JSON that is a string. Note that a JSON document is a string only if it is a sequence of Unicode characters enclosed in double quotation marks. That is, \n\"I am a string\"\n is a valid JSON document that satisfies the above schema, but so is the sequence \n\"42\"\n, or \n\"true\"\n. On the other hand\n\n42\n is a JSON document that will \nnot\n satisfy the above schema, and neither will the document \ntrue\n.   \n\n\nRestrictions\n\n\nIn order to control the length of our string we can use the keywords \nminLength\n and \nmaxLength\n. To restrict the shape of the string even further we can specify that it conforms to a regular expression using the keyword \npattern\n. \n\n\nRestricting the length of a string\n\n\nIn order to specify that the length of a string has to fall into a particular interval we use the \nminLength\n and \nmaxLength\n keywords. For instance, the following schema\n\n\n{\n  \"type\": \"string\", \n  \"minLength\": 3,\n  \"maxLength\": 7\n}\n\n\n\n\nspecifies that our JSON document is a string whose minimum length is three and whose maximum length is 7. The keywords  \nminLength\n and \nmaxLength\n always have a non-negative integer as their value. The document \n\"This is\"\n will satisfy the above schema, as it is of length seven. On the other hand \n\"Is\"\n, or \n\"This is not valid\"\n will not satisfy the schema, as the former is too short, while the latter is too long.\n\n\nRegular expressions\n\n\nIn order to specify that a string conforms to a regular expression we use the keyword \npattern\n. For instance, if we want to enforce that the string is a valid email address with the extension \ngmail.com\n that contains only letters of the alphabet, we could use the following JSON Schema.\n\n\n{\n  \"type\": \"string\", \n  \"pattern\": \"^[A-Za-z]*@gmail.com$\"\n}\n\n\n\n\nHere we are specifying that the email address must end with \n@gmail.com\n, while the part \n[A-Za-z]*\n allows any string consisting of either lower or upper case characters. The symbols \n^\n and \n$\n are used to signify that the matching of a regular expression is done against the entire string. Therefore, the the schema above will validate the document \n\"adam@gmail.com\"\n, but it will reject \n\"g42s@gmail.com\"\n, as the first part of the email contains a character that is not a letter, or anything that is not a string.\n\n\nFor a more detailed introduction to regular expressions we refer the reader to check out the \nRegexOne website\n.\n\n\nFormal Specification\n\n\nString Schemas \nstrSch\n are formally specified using the following grammar.\n\n\n\n\nstrSch\n := \nstrRes (, strRes)*\n\n\nstrRes\n := \ntypeStr\n | \nminLen\n | \nmaxLen\n | \npattern\n\n\ntypeStr\n := \"type\": \"string\"\n\nminLen\n := \"minLength\": n\n\nmaxLen\n := \"maxLength\": \" n\n\npattern\n := \"pattern\": r\n\n\n\n\nwhere each \nstrRes\n token appears at most once in \nstrSch\n, n is an arbitrary non-negative integer and r is a regular expression as specified in \nRegexOne website\n.\n\n\nFormal Validation\n\n\nLet \nS\n be a String Schema and \nJ\n a JSON document. We say that \nJ\n validates against \nS\n if for each name/value pair \nk\n in \nS\n one of the following holds:\n\n\n\n\nk\n is of the form \n\"type\": \"string\"\n and \nJ\n is a string\n\n\nk\n is of the form \n\"minLength\" : n\n and \nJ\n is a string of length at least n\n\n\nk\n is of the form \n\"maxLength\" : n\n and \nJ\n is a string of length at most n\n\n\nk\n is of the form \n\"pattern\" : r\n and \nJ\n is a string that matches the regular expression r\n\n\n\n\nNote that in the formal definition we don not enforce the keyword \ntype\n to be specified. For instance the Schema\n\n\n{\n  \"minLength\": 3,\n  \"maxLength\": 7\n}\n\n\n\n\nis well specified and will match any string whose length is between three and seven characters. This is a consequence of the fact that in the absence of explicit type definition we can still infer the base type by parsing other keywords. We would, however, like to stress that explicitly specifying the type is a good practice that should always be adhered to.\n\n\nNumeric Schemas\n\n\nAnother form of value in JSON are numbers. In JSON Schema we can \nspecify that a document must be a number by using the \ntype\n keyword. The document\n\n\n{\ntype\n:\nnumber\n}\n\n\n\n\nis a JSON Schema, and validates against any numeric value. For example, values \n34\n and \n1.82\n satisfy \n{\"type\":\"number\"}\n, while \n\"34\"\ndoes not, because it is a string. \n\n\nIf we need to specify that a value must be an integer, we use instead the keyword \ninteger\n:\n\n\n{\ntype\n:\ninteger\n}\n\n\n\n\nNow the value \n34\n satisfies this schema, but \n1.82\n does not. \n\n\nRestrictions\n\n\nWe can also specify additional constraints that the numbers must satisfy. All of these keywords can be use by either \nnumber\n\nor \ninteger\n types.\n\n\nRange\n\n\nSuppose we need to specify a value for the age of a person, and we want it to be an integer between 0 and 150. We use the \n\nminimum\n and \nmaximum\n keywords: \n\n\n{\n   \"type\":\"integer\", \n   \"minimum\": 0, \n   \"maximum: 150\n  }\n\n\nThis document validates against any number between \n0\n and \n150\n.\nBy default the ranges are inclusive: \n\"minimum\": n\n imposes the restriction that numbers need to be \ngreater than or equal to\n \nn\n, and \n\"minimum\": m\n imposes that numbers need to be \nless than or equal to\n \nm\n. This means that both \n0\n and \n150\n satisfy the schema above. We can switch the ranges to be exclusive by using the \nexclusiveMinimum\n and \nexclusiveMaximum\n keywords. \n\n\nFor example, the following schema validates against \n0\n, but not against \n150\n:\n\n\n{\n   \"type\":\"integer\", \n   \"minimum\": 0, \n   \"maximum: 150,\n   \"exclusiveMaximum\":true\n  }\n\n\nIf the \n\"minimum\": n\n keyword is present together with the keyword \n\"exclusiveMinimum\":true\n then the restriction imposes that numbers must be \ngreater\n than \nn\n, and if the \n\"maximum\": m\n keyword is present together with \n\"exclusiveMaximum\":true\n then the restriction is that the number must be \nlower than\n \nm\n. \n\n\nMultiplicity\n\n\nWe can also specify that a number must be the multiple of another number,a s in the following schema:\n\n\n{\n   \"type\":\"integer\", \n   \"multipleOf\": 10\n  }\n\nThis schema validates against any number that is a multiple of \n10\n. \nNote that we can also use real numbers in \nmultipleOf\n, and we can combine it with range restrictions. For example, the schema \n\n\n{\n   \"type\":\"integer\", \n   \"multipleOf\": 3.3,\n   \"maximum\": 7\n  }\n\nvalidates against numbers \n3.3\n and \n6.6\n.\n\n\nFormal Specification\n\n\nNumeric schemas \nnumSch\n are constructed using the following grammar:\n\n\n\n\nnumSch\n := \nnumRes\n (, \nnumRes\n)*\n\nnumRes\n := \ntypeNum\n | \nmin\n | \nmax\n | \nmultiple\n\n\ntypeNum\n := \"type\": (\"number\" | \"integer\") \n\nmin\n := \"minimum\": n (, \"exclusiveMinimum\": bool)?\n\nmax\n := \"maximum\": n (, \"exclusiveMaximum\": bool)?\n\nmultiple\n := \"multipleOf\": n\n\n\n\n\nwhere each \nnumSch\n can have at most one of each \ntypeNum\n, \nmin\n, \nmax\n and \nmultiple\n. Here \nn\n is any number, and \nbool\n is either \ntrue\nor \nfalse\n. \n\n\nValidation\n\n\nLet \nN\n be a numeric schema and \nJ\n a JSON document. Then \nN\n validates against \nJ\n if for each name/value pair \nk\n in \nN\n, one of the following holds: \n\n\n\n\nk\n is \n\"type\":\"number\"\n and \nJ\n is a number, or\n\n\nk\n is \n\"type\":\"integer\"\n and \nJ\n is an integer number (a number without the decimal \n.\n marker), or\n\n\nk\n is \n\"multipleOf\": n\n, for some number \nn\n, and \nJ\n is a number that is a multpiple of \nn\n, or \n\n\nk\n is \n\"minimum\": n\n, for some number \nn\n, and \nJ\n is a number that is greater than or equal to \nn\n, or\n\n\nk\n is \n\"maximum\": m\n, for some number \nm\n, and \nJ\n is a number that is lower than or equal to \nm\n, or\n\n\nk\n is \n\"exclusiveMinimum\": true\n, the pair \n\"minimum\": n\n for some number \nn\n is also in \nN\n, and \nJ\n is a number that is greater than \nn\n, or\n\n\nk\n is \n\"exclusiveMaximum\": true\n, the pair \n\"maximum\": m\n for some number \nm\n is also in \nN\n, and \nJ\n is a number that is lower than \nm\n, or\n\n\n\n\nBoolean Schemas\n\n\nIn order to specify a property that can be either true or false we use the value type \nboolean\n. A JSON Schema specifying the type \nboolean\n is given below.\n\n\n{\"type\": \"boolean\"}\n\n\n\nThis schema will validate only aginst JSON documents \ntrue\n and \nfalse\n. Any document of diferent form or of different type, such as \n\"true\"\n, \n42\n, or \n\"Number\"\n, will not satsfy the schema. Note that values that usually evaluate to boolean values in programming languages, such as \n0\n and \n1\n are also not permitted.\n\n\nFormal Specification\n\n\nA Boolean Schema \nboolSch\n is formally specified using the following grammar.\n\n\n\n\nboolSch\n := \"type\": \"boolean\"\n\n\n\n\nFormal Validation\n\n\nLet \nB\n be a Boolean Schema and \nJ\n a JSON document. We say that \nJ\n validates against \nB\n if:\n\n\n\n\nJ\n is either \ntrue\n or \nfalse\n\n\n\n\nNull Schemas\n\n\nWhen specifying that a certain value is missing it is usual to use the type \nnull\n. A JSON Schema specifying null values is given below.\n\n\n{\"type\": \"null\"}\n\n\n\nThis schema will validate aginst JSON document \nnull\n and reject all other JSON documents. Therefore documents such as \n\"false\"\n, \nfalse\n or \n0\n will not validate against the schema above.\n\n\nFormal Specification\n\n\nA Schema \nnullSch\n for \nnull\n values is formally specified using the following grammar.\n\n\n\n\nboolSch\n := \"type\": \"null\"\n\n\n\n\nFormal Validation\n\n\nLet \nN\n be a Schema for \nnull\n values and \nJ\n a JSON document. We say that \nJ\n validates against \nN\n if:\n\n\n\n\nJ\n equals \nnull", 
            "title": "Basic Types"
        }, 
        {
            "location": "/spec/basic_types/#basic-types", 
            "text": "JSON Documents can be either values or ordered or unordered list of name/value pairs. We can use JSON Schema to specify that documents can be any of these. For now we concentrate on the specification for values. There are five basic value types supported by JSON Schema:   string   number    integer   boolean   null", 
            "title": "Basic Types"
        }, 
        {
            "location": "/spec/basic_types/#string-schemas", 
            "text": "One of the most basic forms of values that appear in JSON documents are strings of text. In JSON schema we can specify that a document is a string by using the keyword  string  as the value of the name  type . That is, the document  {\"type\": \"string\"}  is a JSON Schema that valiadates against any JSON that is a string. Note that a JSON document is a string only if it is a sequence of Unicode characters enclosed in double quotation marks. That is,  \"I am a string\"  is a valid JSON document that satisfies the above schema, but so is the sequence  \"42\" , or  \"true\" . On the other hand 42  is a JSON document that will  not  satisfy the above schema, and neither will the document  true .     Restrictions  In order to control the length of our string we can use the keywords  minLength  and  maxLength . To restrict the shape of the string even further we can specify that it conforms to a regular expression using the keyword  pattern .   Restricting the length of a string  In order to specify that the length of a string has to fall into a particular interval we use the  minLength  and  maxLength  keywords. For instance, the following schema  {\n  \"type\": \"string\", \n  \"minLength\": 3,\n  \"maxLength\": 7\n}  specifies that our JSON document is a string whose minimum length is three and whose maximum length is 7. The keywords   minLength  and  maxLength  always have a non-negative integer as their value. The document  \"This is\"  will satisfy the above schema, as it is of length seven. On the other hand  \"Is\" , or  \"This is not valid\"  will not satisfy the schema, as the former is too short, while the latter is too long.  Regular expressions  In order to specify that a string conforms to a regular expression we use the keyword  pattern . For instance, if we want to enforce that the string is a valid email address with the extension  gmail.com  that contains only letters of the alphabet, we could use the following JSON Schema.  {\n  \"type\": \"string\", \n  \"pattern\": \"^[A-Za-z]*@gmail.com$\"\n}  Here we are specifying that the email address must end with  @gmail.com , while the part  [A-Za-z]*  allows any string consisting of either lower or upper case characters. The symbols  ^  and  $  are used to signify that the matching of a regular expression is done against the entire string. Therefore, the the schema above will validate the document  \"adam@gmail.com\" , but it will reject  \"g42s@gmail.com\" , as the first part of the email contains a character that is not a letter, or anything that is not a string.  For a more detailed introduction to regular expressions we refer the reader to check out the  RegexOne website .  Formal Specification  String Schemas  strSch  are formally specified using the following grammar.   strSch  :=  strRes (, strRes)*  strRes  :=  typeStr  |  minLen  |  maxLen  |  pattern  typeStr  := \"type\": \"string\" minLen  := \"minLength\": n maxLen  := \"maxLength\": \" n pattern  := \"pattern\": r  where each  strRes  token appears at most once in  strSch , n is an arbitrary non-negative integer and r is a regular expression as specified in  RegexOne website .  Formal Validation  Let  S  be a String Schema and  J  a JSON document. We say that  J  validates against  S  if for each name/value pair  k  in  S  one of the following holds:   k  is of the form  \"type\": \"string\"  and  J  is a string  k  is of the form  \"minLength\" : n  and  J  is a string of length at least n  k  is of the form  \"maxLength\" : n  and  J  is a string of length at most n  k  is of the form  \"pattern\" : r  and  J  is a string that matches the regular expression r   Note that in the formal definition we don not enforce the keyword  type  to be specified. For instance the Schema  {\n  \"minLength\": 3,\n  \"maxLength\": 7\n}  is well specified and will match any string whose length is between three and seven characters. This is a consequence of the fact that in the absence of explicit type definition we can still infer the base type by parsing other keywords. We would, however, like to stress that explicitly specifying the type is a good practice that should always be adhered to.", 
            "title": "String Schemas"
        }, 
        {
            "location": "/spec/basic_types/#numeric-schemas", 
            "text": "Another form of value in JSON are numbers. In JSON Schema we can \nspecify that a document must be a number by using the  type  keyword. The document  { type : number }  is a JSON Schema, and validates against any numeric value. For example, values  34  and  1.82  satisfy  {\"type\":\"number\"} , while  \"34\" does not, because it is a string.   If we need to specify that a value must be an integer, we use instead the keyword  integer :  { type : integer }  Now the value  34  satisfies this schema, but  1.82  does not.   Restrictions  We can also specify additional constraints that the numbers must satisfy. All of these keywords can be use by either  number \nor  integer  types.  Range  Suppose we need to specify a value for the age of a person, and we want it to be an integer between 0 and 150. We use the  minimum  and  maximum  keywords:   {\n   \"type\":\"integer\", \n   \"minimum\": 0, \n   \"maximum: 150\n  }  This document validates against any number between  0  and  150 .\nBy default the ranges are inclusive:  \"minimum\": n  imposes the restriction that numbers need to be  greater than or equal to   n , and  \"minimum\": m  imposes that numbers need to be  less than or equal to   m . This means that both  0  and  150  satisfy the schema above. We can switch the ranges to be exclusive by using the  exclusiveMinimum  and  exclusiveMaximum  keywords.   For example, the following schema validates against  0 , but not against  150 :  {\n   \"type\":\"integer\", \n   \"minimum\": 0, \n   \"maximum: 150,\n   \"exclusiveMaximum\":true\n  }  If the  \"minimum\": n  keyword is present together with the keyword  \"exclusiveMinimum\":true  then the restriction imposes that numbers must be  greater  than  n , and if the  \"maximum\": m  keyword is present together with  \"exclusiveMaximum\":true  then the restriction is that the number must be  lower than   m .   Multiplicity  We can also specify that a number must be the multiple of another number,a s in the following schema:  {\n   \"type\":\"integer\", \n   \"multipleOf\": 10\n  } \nThis schema validates against any number that is a multiple of  10 . \nNote that we can also use real numbers in  multipleOf , and we can combine it with range restrictions. For example, the schema   {\n   \"type\":\"integer\", \n   \"multipleOf\": 3.3,\n   \"maximum\": 7\n  } \nvalidates against numbers  3.3  and  6.6 .  Formal Specification  Numeric schemas  numSch  are constructed using the following grammar:   numSch  :=  numRes  (,  numRes )* numRes  :=  typeNum  |  min  |  max  |  multiple  typeNum  := \"type\": (\"number\" | \"integer\")  min  := \"minimum\": n (, \"exclusiveMinimum\": bool)? max  := \"maximum\": n (, \"exclusiveMaximum\": bool)? multiple  := \"multipleOf\": n  where each  numSch  can have at most one of each  typeNum ,  min ,  max  and  multiple . Here  n  is any number, and  bool  is either  true or  false .   Validation  Let  N  be a numeric schema and  J  a JSON document. Then  N  validates against  J  if for each name/value pair  k  in  N , one of the following holds:    k  is  \"type\":\"number\"  and  J  is a number, or  k  is  \"type\":\"integer\"  and  J  is an integer number (a number without the decimal  .  marker), or  k  is  \"multipleOf\": n , for some number  n , and  J  is a number that is a multpiple of  n , or   k  is  \"minimum\": n , for some number  n , and  J  is a number that is greater than or equal to  n , or  k  is  \"maximum\": m , for some number  m , and  J  is a number that is lower than or equal to  m , or  k  is  \"exclusiveMinimum\": true , the pair  \"minimum\": n  for some number  n  is also in  N , and  J  is a number that is greater than  n , or  k  is  \"exclusiveMaximum\": true , the pair  \"maximum\": m  for some number  m  is also in  N , and  J  is a number that is lower than  m , or", 
            "title": "Numeric Schemas"
        }, 
        {
            "location": "/spec/basic_types/#boolean-schemas", 
            "text": "In order to specify a property that can be either true or false we use the value type  boolean . A JSON Schema specifying the type  boolean  is given below.  {\"type\": \"boolean\"}  This schema will validate only aginst JSON documents  true  and  false . Any document of diferent form or of different type, such as  \"true\" ,  42 , or  \"Number\" , will not satsfy the schema. Note that values that usually evaluate to boolean values in programming languages, such as  0  and  1  are also not permitted.  Formal Specification  A Boolean Schema  boolSch  is formally specified using the following grammar.   boolSch  := \"type\": \"boolean\"  Formal Validation  Let  B  be a Boolean Schema and  J  a JSON document. We say that  J  validates against  B  if:   J  is either  true  or  false", 
            "title": "Boolean Schemas"
        }, 
        {
            "location": "/spec/basic_types/#null-schemas", 
            "text": "When specifying that a certain value is missing it is usual to use the type  null . A JSON Schema specifying null values is given below.  {\"type\": \"null\"}  This schema will validate aginst JSON document  null  and reject all other JSON documents. Therefore documents such as  \"false\" ,  false  or  0  will not validate against the schema above.  Formal Specification  A Schema  nullSch  for  null  values is formally specified using the following grammar.   boolSch  := \"type\": \"null\"  Formal Validation  Let  N  be a Schema for  null  values and  J  a JSON document. We say that  J  validates against  N  if:   J  equals  null", 
            "title": "Null Schemas"
        }, 
        {
            "location": "/spec/arrays_objects/", 
            "text": "Arrays \n Objects\n\n\nHere we show how to specify collections of name/value pairs using possibly nested JSON Schemas.\n\n\nArray Type\n\n\nArrays are used to represent sets of values in a single element. As we can see in the following example, we can enumerate a sequence of strings such as nationalities:\n\n\n[\nChilean\n, \nArgentinean\n, \nPeruvian\n, \nColombian\n]\n\n\n\n\n\nOn this section we specify array's main charasteristics and restrictions that may apply to them using a single JSON Schema document.\n\n\nFirst of all, we want to ensure that the element that we are validating is efectively an array with the type restriction, as in the following schema:\n\n\n{\n \ntype\n: \narray\n\n}\n\n\n\n\n\nThe next document doesn't validate against the schema:\n\n\n{\n \nnation1\n: \nchilean\n, \n \nnation2\n: \nargentinean\n,\n \nthis\n: \nis\n,\n \nnot\n: \nan\n,\n \nkeyword\n: \narray\n\n }\n\n\n\n\n\nThis one is correct: \n\n\n[\nChilean\n, \nArgentinean\n, \nthis\n, \nis\n, \nan\n, \narray\n]\n\n\n\n\n\nIn the next sections we describe the restrictions that apply to arrays and how to validate them against the schema. Finally, we give the formal syntax and formal validation for these schemas.\n\n\nRestrictions\n\n\nAs mentioned before, we can restrict the contents of an array using a JSON Schema. For example, if we want to be sure that the items of the array are strings and that we could have at most 10 items we could use the next schema:\n\n\n{\n \ntype\n: \narray\n,\n \nmaxItems\n: 3,\n \nitems\n: {\n          \ntype\n: \nstring\n\n               }\n}\n\n\n\n\n\nThe following JSON document would validate again the schema:\n\n\n[\nChilean\n, \nArgentinean\n]\n\n\n\n\n\nThis one wouln't validate since it has more than 3 elements:\n\n\n[\nChilean\n, \nArgentinean\n, \nPeruvian\n, \nColombian\n]\n\n\n\n\n\nAs we can see, it's very easy to restrict an array using a schema over it. Intuitively a JSON Schema for an array can be seen as set of restrictions that apply for array elements. In the next sections we specificate each restriction and how a JSON document validate against these restrictions.\n\n\nNote\n:  type restriction is also considered a restriction. Thereby it could be present in the JSON Schema as it could not.\n\n\nItem Restriction\n\n\nThese kinds of restrictions are going to apply to the elements of the array. We have two ways to restrict the items of an array. The first way is to restrict all the elements of the array to validate against a schema. Let's take the next schema as an example of the first case:\n\n\n{\n \ntype\n: \narray\n,\n \nitems\n:{\n          \ntype\n: \ninteger\n\n         }\n}\n\n\n\n\nIn this case, we are asking that every element of the array must be an integer. For example, this array is valid against the schema\n\n\n[3, 1, 4, 5]\n\n\n\n\n\nBut this one is not\n\n\n[3, \none\n, 4, 5]\n\n\n\n\n\nThe second way of restricting the items is to specify a JSON Schema to each element of the array. As above, the next schema is an example of the second case use of the items restriction: \n\n\n{\n \ntype\n: \narray\n,\n \nitems\n : [{\n          \ntype\n: \nstring\n\n         },\n         {\n          \ntype\n: \ninteger\n\n         },\n         {\n          \ntype\n: \nboolean\n\n         }\n         ]\n}\n\n\n\n\nIn this case, we are asking that the first element must be a string, the second one an integer and the third one a boolean. For example, this array is valid against the schema\n\n\n[\nChile\n, 1, true]\n\n\n\n\n\nBut this one is not\n\n\n[\nChile\n, \none\n, 4]\n\n\n\n\n\nAdditional Items\n\n\nThis restriction specifies if the array can contain items which are not specified on the schema. Here we have an example of this kind of restriction\n\n\n{\n \ntype\n: \narray\n,\n \nitems\n : [{\n          \ntype\n: \nstring\n\n         },\n         {\n          \ntype\n: \ninteger\n\n         },\n         {\n          \ntype\n: \nboolean\n\n         }\n         ],\n \nadditionalItems\n: false       \n}\n\n\n\n\nIn this example, we are asking that the first element must be a string, the second one an integer and the third one a boolean. But we cannot have any more items than these. Here we can see a JSON that is valid against the schema\n\n\n[\nChile\n, 1, true]\n\n\n\n\n\nBut this one is not\n\n\n[\nChile\n, 1, \ntrue\n]\n\n\n\n\n\nItem Quantity\n\n\nHere we have two kinds of retriction. On one hand we have \n\"minItems\":  \"n\"\n which specifies that the array must have at least n elements. On the other hand we have \n\"maxItems\":  \"n\"\n which specifies that the array cannot have more than n elements. Here we have a useful example of this\n\n\n{\n \ntype\n: \narray\n,\n \nminItems\n: 2,\n \nmaxItems\n: 5\n}\n\n\n\n\nAs we can see, here we are asking for the user to provide an array with at least two elements and no more than five. For example this document validates against the schema\n\n\n[\nChile\n, 16.000.000, \nSan Francisco\n, 800.000]\n\n\n\n\nBut this one doesn't\n\n\n[\nChile\n, 16.000.000, \nSan Francisco\n, 800.000, \nLondon\n, 9.000.000]\n\n\n\n\nUniqueness\n\n\nThis restriction asks the elements of the array to appear exactly once on it. Here we have an example of this\n\n\n{\n \ntype\n: \narray\n,\n \nuniqueItems\n: true\n}\n\n\n\n\nClearly here we are asking for the user to provide an array with no repetitions between it's elements. For example this document validates against the schema\n\n\n[1, 3, 5, 7]\n\n\n\n\nBut this one doesn't\n\n\n[1, 3, 5, 3]\n\n\n\n\nFormal Specification\n\n\nMore formally, the correct grammar for these schemmas can be seen like this:\n\n\n\n \narrSch\n:= \narrRes\n(, \narrRes\n)\n*\n\n\n\n\n\nHere \narrRes\n is a restriction for the type array such that every \narrRes\n must be different from each other and occurs no more than one time each. Each of these restrictions is defined as follows:\n\n\n\n \narrRes\n := \ntypeArr\n | \nitems\n | \nadditems\n | \nminitems\n | \nmaxitems\n  | \nunique\n\n \ntypeArr\n := \"type\": \"array\"\n \nitems\n := ( \nsameitems\n |  \nvaritems\n )\n \nsameitems\n := \"items\": { \nJSch\n }\n \nvaritems\n := \"items\": [{ \nJSch\n }(,{ \nJSch\n })\n*\n]\n \nminitems\n := \"minItems: \" n\n \nmaxitems\n := \"maxItems: \" n\n \nunique\n := \"uniqueItems: \" (true | false)\n\n\n\n\nHere n is a natural number and \nJSch\n a JSON Schema.\n\n\nFormal Validation\n\n\nLet \nA\n be an Array Schema and \nJ\n a JSON document. We say that \nJ\n validates against \nA\n if for each name/value pair \nk\n in \nA\n one of the following holds:\n\n\n\n\nk\n is \n\"type\": \"array\"\n and \nJ\n is an array\n\n\nk\n is \n\"items\": s\n and \nJ\n is an array such that every element validates against s\n\n\nk\n is \n\"items\": [s\n1\n , ... , s\nn\n]\n and \nJ\n is an array \n[a\n1\n , ... , a\nm\n]\n such that every element a\ni\n validates against s\ni\n with i \u2264 Min(m,n).\n\n\nk\n is \n\"minItems\": n\n and \nJ\n is an array with at least n elements\n\n\nk\n is \n\"maxItems\": n\n and \nJ\n is an array with at most n elements\n\n\nk\n is \n\"uniqueItems\": true\n and \nJ\n is an array with all elements different from each other\n\n\n\n\nObject Schemas\n\n\nObjects in JSON are collections of name/value pairs, where the values in these pairs can be again any JSON Document. \nJSON schemas that specify objects are called \nObject Schemas\n. The document\n\n\n{\ntype\n: \nobject\n}\n\n\n\n\nIs an Object Schema. It validates against any JSON document that is an object, such as \n\n\n{\n  \nfirst_name\n: \nGary\n, \n  \nlast_name\n: \nMedel\n\n}\n\n\n\n\nor \n\n\n{\n  \nname\n: {\nfirst\n: \nGary\n, \nlast\n: \nMedel\n}, \n  \nage\n: 27\n}\n\n\n\n\nbut not \n\n\n[\nthis\n,\nlist\n,\nis\n,\nordered\n]\n\n\n\n\nRestrictions\n\n\nUsing JSON Schema we have several keywords to specify which kinds of objects we allow. For example, if we want to specify documents that include \nfirst_name\n, \nlast_name\n and \nage\n, we use\n\n\n{\n    \ntype\n: \nobject\n,\n    \nrequired\n: [\nfirst_name\n, \nlast_name\n, \nage\n]\n}\n\n\n\n\nThis means that this schema validates against object types that have at least pairs with names \nfirst_name\n, \n\nlast_name\n and \nage\n. However, we have not stated any restrictions for the values of this pairs. This means that the following document validates against this schema: \n\n\n{\n    \nfirst_name\n: 4,\n    \nlast_name\n: true,\n    \nage\n: \nwhatever\n\n}\n\n\n\n\nNot very informative, right? Ideally we would like the values of \nfirst_name\n and \nlast_name\n be strings and \nage\n be an integer. We do it as follows: \n\n\n{\n    \ntype\n: \nobject\n,\n    \nrequired\n: [\nfirst_name\n, \nlast_name\n, \nage\n],\n    \nproperties\n: {\n        \nfirst_name\n: {\ntype\n: \nstring\n},\n        \nlast_name\n: {\ntype\n: \nstring\n},\n        \nage\n: {\ntype\n: \ninteger\n}\n    }\n}\n\n\n\n\nThis time, the only documents that validate against the schema are those that looke like this one:\n\n\n{\n    \nfirst_name\n: \nGary\n,\n    \nlast_name\n: \nMedel\n,\n    \nage\n: 27\n}\n\n\n\n\nNext we review all restrictions avaliable for Object Schemas. \n\n\nRequired\n\n\nAs we have mentioned, we use \nrequired\n to specify a list of strings that need to be present as the name of the pairs of the documents. In general, a schema of the form \n\n\n{\n    \ntype\n: \nobject\n,\n    \nrequired\n: [\na\n, \nb\n, \nc\n, \nd\n, . . .]\n}\n\n\n\n\nSpecifies documents that need to have pairs with names \n\"a\"\n, \n\"b\"\n, \n\"c\"\n, \n\"d\"\n, etc. \n\n\nProperties\n\n\nThe \nproperty\n keyword is used to specify the name/value pairs of JSON documents. The value of \nproperty\n is itself a name/value pair: the value can be any JSON schema, it is used to specify how the value of the name/value pair should look. For example, the following schema specifies that objects should have at least two pairs, with keys \nfirst\n and \nlast\n, and the values o f those must be strings. \n\n\n{\n    \ntype\n: \nobject\n,\n    \nrequired\n: [\nfirst\n, \nlast\n],\n    \nproperties\n: {\n        \nfirst\n: {\ntype\n: \nstring\n},\n        \nlast\n: {\ntype\n: \nstring\n}\n    }\n}\n\n\n\n\nNow lets say we want to specify football players. They should have a \nname\n, \nage\n and a \nclub_name\n, and the \nname\n should consist of a \nfirst name\n and a \nlast name\n. We do it with the following schema: \n\n\n{\n    \"type\": \"object\",\n    \"required\": [\"name\", \"age\",\"club_name\"],\n    \"properties\": {\n           \"name\": {\n               \"type\": \"object\",\n               \"required\": [\"first\", \"last\"]\n               \"properties\": {\n                       \"first\": {\"type\": \"string\"},\n                       \"last\": {\"type\": \"string\"}\n               }\n           },\n           \"age\": {\"type\": \"integer\"}, \n           \"club_name\": {\"type\": \"string\"}\n    }\n}\n\n\nNote that the schema under \n\"name\"\n is again another Object Schema. We can do this as many times as we want! The following document validates against this schema\n\n\n{\n   name: {\n      \nfirst_name\n: \nGary\n,\n      \nlast_name\n: \nMedel\n\n   },\n   \nage\n: 27,\n   \nclub_name\n: \nInter de Milan\n\n}\n\n\n\n\nBy default the names specified under \nproperties\n are not required, this means that, for example, the empty document \n\n\n{}\n\n\n\n\nvalidates against the schema \n\n\n{\n    \ntype\n: \nobject\n,\n    \nproperties\n: {\n        \nfirst\n: {\ntype\n: \nstring\n},\n        \nlast\n: {\ntype\n: \nstring\n}\n    }\n}\n\n\n\n\nFor validation purproses the \nproperties\n keyword should be understood as follows: if a document has a name/value pair \nand\n this name is specified in \nproperties\n, then the value of this pair needs to validate against the schema specified under this name in \nproperties\n. \n\n\nAdditional Properties\n\n\nNote that \nproperties\n does not state aything about the structure of any additional names not specified in this keyword. The \nadditionalProperties\n keyword is used both to state if the document will support additional properties from the ones named on \nproperties\n restriction and to give an schema for these extra properties. For example, lets see the following schema \n\n\n{\n    \ntype\n: \nobject\n,\n    \nproperties\n: {\n        \nfirst\n: {\ntype\n: \nstring\n},\n        \nlast\n: {\ntype\n: \nstring\n}\n    },\n    \nadditionalProperties\n: false\n}\n\n\n\n\nIn this case we are asking for documents that to don't have any properties whose keywords are different from \"first\" and \"last\". For instance, this document would not be valid:\n\n\n{\n    \nfirst\n: \nGary\n,\n    \nlast\n: \nMedel\n,\n    \nage\n: 25\n}\n\n\n\n\nOther use of \nadditionalProperties\n is to restrict the structure of extra properties provided. For example, lets see the following schema \n\n\n{\n    \ntype\n: \nobject\n,\n    \nproperties\n: {\n        \nfirst\n: {\ntype\n: \nstring\n},\n        \nlast\n: {\ntype\n: \nstring\n}\n    },\n    \nadditionalProperties\n: {\n                             \ntype\n: \ninteger\n\n                            }\n}\n\n\n\n\nHere we are asking that any keywords different from \"first\" and \"last\" must have integer values. For example the next JSON document validates against the schema\n\n\n{\n    \nfirst\n: \nGary\n,\n    \nlast\n: \nMedel\n,\n    \nage\n: 25\n}\n\n\n\n\nBut this one doesn't\n\n\n{\n    \nfirst\n: \nGary\n,\n    \nlast\n: \nMedel\n,\n    \nage\n: \ntwenty five\n\n\n}\n\n\n\n\nNumber of Properties\n\n\nThe \nminProperties\nand \nmaxProperties\n keywords are used to restrict the number of properties allowed on a JSON object. For example, lets see the following schema \n\n\n{\n    \ntype\n: \nobject\n,\n    \nminProperties\n: 3,\n    \nmaxProperties\n: 5\n\n}\n\n\n\n\nHere we are asking for JSON objects with at least 3 properties and no more than 5. For example this object would validate against the schema\n\n\n{\n    \nfirst\n: 10,\n    \nsecond\n: 11,\n    \nthird\n: 12,\n    \nfour\n: 13\n}\n\n\n\n\nbut this one doesn't\n\n\n{\n    \nfirst\n: 10,\n    \nsecond\n: 11\n}\n\n\n\n\nDependencies\n\n\nDependecies are used to modify the schema in function of the properties that de JSON object provides. There is two ways of doing this with \ndependencies\n keyword. The first one is used to force the presence of some properties if a particular keyword is provided by the object. Let's see the following example\n\n\n{\n    \ntype\n: \nobject\n,\n    \nproperties\n: {\n        \nfirst\n: {\ntype\n: \nstring\n},\n        \nlast\n: {\ntype\n: \nstring\n},\n        \nteam\n: {\ntype\n: \nstring\n},\n        \nleague\n: {\ntype\n: \nstring\n}\n            },\n    \nrequired\n: [\nfirst\n, \nlast\n],\n    \ndependencies\n:{\n                        \nteam\n: [\nleague\n]    \n                      }\n}\n\n\n\n\nHere we are going to accept all schemas that contains the properties \"first\" and \"last\", but if the object has the property \"team\" then the property \"league\" becomes a required property. For example, this document is valid against the schema\n\n\n{\n    \nfirst\n: \nGary\n,\n    \nsecond\n: \nMedel\n,\n    \nteam\n: \nInter de Milan\n,\n    \nleague\n: \nSerie A\n\n}\n\n\n\n\nbut this one is not valid\n\n\n{\n    \nfirst\n: \nGary\n,\n    \nsecond\n: \nMedel\n,\n    \nteam\n: \nInter de Milan\n\n}\n\n\n\n\nThe other way of using \ndependencies\n keyword is to ask the JSON object to satisfy another JSON Schema in the presence of certain keywords. Lets take the following schema as an example\n\n\n{\n    \ntype\n: \nobject\n,\n    \nproperties\n: {\n        \nfirst\n: {\ntype\n: \nstring\n},\n        \nlast\n: {\ntype\n: \nstring\n},\n        \nteam\n: {\ntype\n: \nstring\n}\n            },\n    \nrequired\n: [\nfirst\n, \nlast\n],\n    \ndependencies\n:{\n                        \nteam\n: {\n                        \nproperties\n: {\n                            \nleague\n: {\ntype\n: \nstring\n},\n                            \ngoals\n: {\ntype\n: \ninteger\n}\n                                         },\n                       \nrequired\n: [\nleague\n, \ngoals\n]\n                        }  \n                      }\n}\n\n\n\n\nHere we ask the JSON object to have the properties \"league\" and \"goals\" in the presence of \"team\" property. For example the next object validates against the schema\n\n\n{\n    \nfirst\n: \nGary\n,\n    \nsecond\n: \nMedel\n,\n    \nteam\n: \nInter de Milan\n,\n    \nleague\n: \nSerie A\n,\n    \ngoals\n: 5\n}\n\n\n\n\nBut this one doesn't\n\n\n{\n    \nfirst\n: \nGary\n,\n    \nsecond\n: \nMedel\n,\n    \nteam\n: \nInter de Milan\n,\n    \ngoals\n: 5\n}\n\n\n\n\nPattern Properties\n\n\nSometimes we will want to restrict a set of properties depending if they share a pattern on they keywords. The \npatternProperties\n keyword is used to restrict keywords matching to a certain regular expression. Let's see a example of this\n\n\n{\n    \ntype\n: \nobject\n,\n    \nproperties\n: {\n        \nfirst\n: {\ntype\n: \nstring\n},\n        \nlast\n: {\ntype\n: \nstring\n},\n        \nteam\n: {\ntype\n: \nstring\n},\n        \nleague\n: {\ntype\n: \nstring\n}\n            },\n   \npatternProperties\n: {\n       \n_goals$\n: { \ntype\n: \ninteger\n }\n  }\n}\n\n\n\n\nHere we are asking that properties matching the regular expression  \n_goals$\n must be integers. For example the following JSON object validates against the schema\n\n\n{\n    \nfirst\n: \nGary\n,\n    \nsecond\n: \nMedel\n,\n    \nteam\n: \nInter de Milan\n,\n    \nleague\n: \nSerie A\n,\n    \nleague_goals\n: 5,\n    \ninternational_goals\n: 2\n}\n\n\n\n\nbut this one doesn't\n\n\n{\n    \nfirst\n: \nGary\n,\n    \nsecond\n: \nMedel\n,\n    \nteam\n: \nInter de Milan\n,\n    \nleague\n: \nSerie A\n,\n    \nleague_goals\n: \nfive\n\n}\n\n\n\n\nFormal Specification\n\n\nMore formally, the correct grammar for these schemmas can be seen like this:\n\n\n\n \nobjSch\n:= \nobjRes\n(, \nobjRes\n)\n*\n\n\n\n\n\nHere \nobjRes\n is a restriction for objects such that every \nobjRes\n must be different from each other in the schema and occurs no more than one time each. Each of these restrictions is defined as follows:\n\n\n\n \narrRes\n := \ntypeObj\n | \nprop\n | \naddprop\n | \nreq\n | \nminprop\n | \nmaxprop\n | \ndep\n| \npattprop\n\n \ntypeObj\n := \"type\": \"object\"\n \nprop\n := \"properties: \"{ \nkSch\n (, \nkSch\n)\n*\n}\n \naddprop\n := \"additionalProperties\": (true | false | { \nJSch\n })\n \nreq\n := \"required\": [ \nkword\n (, \nkword\n)\n*\n]\n \nminprop\n := \"minProperties: \" n\n \nmaxprop\n := \"maxProperties: \" n\n \ndep\n := \"dependencies: \"(\ndepArr\n | \ndepSch\n)\n \ndepArr\n := { \nkArr\n (, \nkArr\n)\n*\n}\n \ndepSch\n := { \nkSch\n (, \nkSch\n)\n*\n}\n \nkArr\n := \nkword\n: [ \nkword\n (, \nkword\n)\n*\n]\n \npattprop\n := \"patternProperties: \"{ \npatSch\n (, \npatSch\n)\n*\n}\n \npatSch\n := regexp: { \nJSch\n } \n\n\n\nHere n is a natural number and \nJSch\n a JSON Schema. Similarly \nkSch\n is a pair \nkeyword: schema\n.\n\n\nFormal Validation\n\n\nLet \nO\n be an object Schema and \nJ\n a JSON document. We say that \nJ\n validates against \nO\n if for each name/value pair \nk\n in \nO\n one of the following holds:\n\n\n\n\nk\n is \n\"type\": \"object\"\n and \nJ\n is an object\n\n\nk\n is \n\"properties\": {k\n1\n: s\n1\n , ... , k\nn\n: s\nn\n}\n and \nJ\n is an object that for each key-value pair \nk': j'\n in \nJ\n, if \nk' = k\ni\n for some i in [1 , ... , n] then \nj'\n satisfies \ns\ni\n\n\nk\n is \n\"additionalProperties\": false\n and \nJ\n is an object such that every keyword in \nJ\n is mentioned in \n\"properties\": {k\n1\n: s\n1\n , ... , k\nn\n: s\nn\n}\n\n\nk\n is \n\"additionalProperties\": true\n and \nJ\n is an object\n\n\nk\n is \n\"additionalProperties\": s\n and \nJ\n is an object that for each key-value pair \nk': j'\n in \nJ\n such that \nk'\n is different from every \nk\ni\n in \n\"properties\": {k\n1\n: s\n1\n , ... , k\nn\n: s\nn\n}\n and \nj'\n satisfies \ns\n\n\nk\n is \n\"required\": [k\n1\n , ... , k\nn\n]\n and \nJ\n is an object such that every keyword \nk\ni\n appears on \nJ\n properties\n\n\nk\n is \n\"minProperties\": n\n and \nJ\n is an object with at least n properties\n\n\nk\n is \n\"maxProperties\": n\n and \nJ\n is an object with at most n properties\n\n\nk\n is \n\"dependencies\": {k\n1\n: [k\n1\n], ... , k\nn\n: [k\nn\n]}\n and \nJ\n is an object such that if k\ni\n appears on \nJ\n then every keyword in [k\ni\n] appears in \nJ\n\n\nk\n is \n\"dependencies\": {k\n1\n: s\n1\n , ... , k\nn\n: s\nn\n}\n  and \nJ\n is an object such that if k\ni\n appears on \nJ\n then \nJ\n must satisfy \nO\n and s\ni\n\n\nk\n is \n\"patternProperties\": {regexp\n1\n: s\n1\n , ... , regexp\nn\n: s\nn\n}\n and \nJ\n is an object that for each key-value pair \nk': j'\n in \nJ\n, if \nk'\n is in the language of  regexp\ni\n for some i in [1,..., n] then \nj'\n satisfies \ns\ni", 
            "title": "Arrays & Objects"
        }, 
        {
            "location": "/spec/arrays_objects/#arrays-objects", 
            "text": "Here we show how to specify collections of name/value pairs using possibly nested JSON Schemas.", 
            "title": "Arrays &amp; Objects"
        }, 
        {
            "location": "/spec/arrays_objects/#array-type", 
            "text": "Arrays are used to represent sets of values in a single element. As we can see in the following example, we can enumerate a sequence of strings such as nationalities:  [ Chilean ,  Argentinean ,  Peruvian ,  Colombian ]  On this section we specify array's main charasteristics and restrictions that may apply to them using a single JSON Schema document.  First of all, we want to ensure that the element that we are validating is efectively an array with the type restriction, as in the following schema:  {\n  type :  array \n}  The next document doesn't validate against the schema:  {\n  nation1 :  chilean , \n  nation2 :  argentinean ,\n  this :  is ,\n  not :  an ,\n  keyword :  array \n }  This one is correct:   [ Chilean ,  Argentinean ,  this ,  is ,  an ,  array ]  In the next sections we describe the restrictions that apply to arrays and how to validate them against the schema. Finally, we give the formal syntax and formal validation for these schemas.  Restrictions  As mentioned before, we can restrict the contents of an array using a JSON Schema. For example, if we want to be sure that the items of the array are strings and that we could have at most 10 items we could use the next schema:  {\n  type :  array ,\n  maxItems : 3,\n  items : {\n           type :  string \n               }\n}  The following JSON document would validate again the schema:  [ Chilean ,  Argentinean ]  This one wouln't validate since it has more than 3 elements:  [ Chilean ,  Argentinean ,  Peruvian ,  Colombian ]  As we can see, it's very easy to restrict an array using a schema over it. Intuitively a JSON Schema for an array can be seen as set of restrictions that apply for array elements. In the next sections we specificate each restriction and how a JSON document validate against these restrictions.  Note :  type restriction is also considered a restriction. Thereby it could be present in the JSON Schema as it could not.  Item Restriction  These kinds of restrictions are going to apply to the elements of the array. We have two ways to restrict the items of an array. The first way is to restrict all the elements of the array to validate against a schema. Let's take the next schema as an example of the first case:  {\n  type :  array ,\n  items :{\n           type :  integer \n         }\n}  In this case, we are asking that every element of the array must be an integer. For example, this array is valid against the schema  [3, 1, 4, 5]  But this one is not  [3,  one , 4, 5]  The second way of restricting the items is to specify a JSON Schema to each element of the array. As above, the next schema is an example of the second case use of the items restriction:   {\n  type :  array ,\n  items  : [{\n           type :  string \n         },\n         {\n           type :  integer \n         },\n         {\n           type :  boolean \n         }\n         ]\n}  In this case, we are asking that the first element must be a string, the second one an integer and the third one a boolean. For example, this array is valid against the schema  [ Chile , 1, true]  But this one is not  [ Chile ,  one , 4]  Additional Items  This restriction specifies if the array can contain items which are not specified on the schema. Here we have an example of this kind of restriction  {\n  type :  array ,\n  items  : [{\n           type :  string \n         },\n         {\n           type :  integer \n         },\n         {\n           type :  boolean \n         }\n         ],\n  additionalItems : false       \n}  In this example, we are asking that the first element must be a string, the second one an integer and the third one a boolean. But we cannot have any more items than these. Here we can see a JSON that is valid against the schema  [ Chile , 1, true]  But this one is not  [ Chile , 1,  true ]  Item Quantity  Here we have two kinds of retriction. On one hand we have  \"minItems\":  \"n\"  which specifies that the array must have at least n elements. On the other hand we have  \"maxItems\":  \"n\"  which specifies that the array cannot have more than n elements. Here we have a useful example of this  {\n  type :  array ,\n  minItems : 2,\n  maxItems : 5\n}  As we can see, here we are asking for the user to provide an array with at least two elements and no more than five. For example this document validates against the schema  [ Chile , 16.000.000,  San Francisco , 800.000]  But this one doesn't  [ Chile , 16.000.000,  San Francisco , 800.000,  London , 9.000.000]  Uniqueness  This restriction asks the elements of the array to appear exactly once on it. Here we have an example of this  {\n  type :  array ,\n  uniqueItems : true\n}  Clearly here we are asking for the user to provide an array with no repetitions between it's elements. For example this document validates against the schema  [1, 3, 5, 7]  But this one doesn't  [1, 3, 5, 3]  Formal Specification  More formally, the correct grammar for these schemmas can be seen like this:  \n  arrSch :=  arrRes (,  arrRes ) *   Here  arrRes  is a restriction for the type array such that every  arrRes  must be different from each other and occurs no more than one time each. Each of these restrictions is defined as follows:  \n  arrRes  :=  typeArr  |  items  |  additems  |  minitems  |  maxitems   |  unique \n  typeArr  := \"type\": \"array\"\n  items  := (  sameitems  |   varitems  )\n  sameitems  := \"items\": {  JSch  }\n  varitems  := \"items\": [{  JSch  }(,{  JSch  }) * ]\n  minitems  := \"minItems: \" n\n  maxitems  := \"maxItems: \" n\n  unique  := \"uniqueItems: \" (true | false)  Here n is a natural number and  JSch  a JSON Schema.  Formal Validation  Let  A  be an Array Schema and  J  a JSON document. We say that  J  validates against  A  if for each name/value pair  k  in  A  one of the following holds:   k  is  \"type\": \"array\"  and  J  is an array  k  is  \"items\": s  and  J  is an array such that every element validates against s  k  is  \"items\": [s 1  , ... , s n ]  and  J  is an array  [a 1  , ... , a m ]  such that every element a i  validates against s i  with i \u2264 Min(m,n).  k  is  \"minItems\": n  and  J  is an array with at least n elements  k  is  \"maxItems\": n  and  J  is an array with at most n elements  k  is  \"uniqueItems\": true  and  J  is an array with all elements different from each other", 
            "title": "Array Type"
        }, 
        {
            "location": "/spec/arrays_objects/#object-schemas", 
            "text": "Objects in JSON are collections of name/value pairs, where the values in these pairs can be again any JSON Document. \nJSON schemas that specify objects are called  Object Schemas . The document  { type :  object }  Is an Object Schema. It validates against any JSON document that is an object, such as   {\n   first_name :  Gary , \n   last_name :  Medel \n}  or   {\n   name : { first :  Gary ,  last :  Medel }, \n   age : 27\n}  but not   [ this , list , is , ordered ]  Restrictions  Using JSON Schema we have several keywords to specify which kinds of objects we allow. For example, if we want to specify documents that include  first_name ,  last_name  and  age , we use  {\n     type :  object ,\n     required : [ first_name ,  last_name ,  age ]\n}  This means that this schema validates against object types that have at least pairs with names  first_name ,  last_name  and  age . However, we have not stated any restrictions for the values of this pairs. This means that the following document validates against this schema:   {\n     first_name : 4,\n     last_name : true,\n     age :  whatever \n}  Not very informative, right? Ideally we would like the values of  first_name  and  last_name  be strings and  age  be an integer. We do it as follows:   {\n     type :  object ,\n     required : [ first_name ,  last_name ,  age ],\n     properties : {\n         first_name : { type :  string },\n         last_name : { type :  string },\n         age : { type :  integer }\n    }\n}  This time, the only documents that validate against the schema are those that looke like this one:  {\n     first_name :  Gary ,\n     last_name :  Medel ,\n     age : 27\n}  Next we review all restrictions avaliable for Object Schemas.   Required  As we have mentioned, we use  required  to specify a list of strings that need to be present as the name of the pairs of the documents. In general, a schema of the form   {\n     type :  object ,\n     required : [ a ,  b ,  c ,  d , . . .]\n}  Specifies documents that need to have pairs with names  \"a\" ,  \"b\" ,  \"c\" ,  \"d\" , etc.   Properties  The  property  keyword is used to specify the name/value pairs of JSON documents. The value of  property  is itself a name/value pair: the value can be any JSON schema, it is used to specify how the value of the name/value pair should look. For example, the following schema specifies that objects should have at least two pairs, with keys  first  and  last , and the values o f those must be strings.   {\n     type :  object ,\n     required : [ first ,  last ],\n     properties : {\n         first : { type :  string },\n         last : { type :  string }\n    }\n}  Now lets say we want to specify football players. They should have a  name ,  age  and a  club_name , and the  name  should consist of a  first name  and a  last name . We do it with the following schema:   {\n    \"type\": \"object\",\n    \"required\": [\"name\", \"age\",\"club_name\"],\n    \"properties\": {\n           \"name\": {\n               \"type\": \"object\",\n               \"required\": [\"first\", \"last\"]\n               \"properties\": {\n                       \"first\": {\"type\": \"string\"},\n                       \"last\": {\"type\": \"string\"}\n               }\n           },\n           \"age\": {\"type\": \"integer\"}, \n           \"club_name\": {\"type\": \"string\"}\n    }\n}  Note that the schema under  \"name\"  is again another Object Schema. We can do this as many times as we want! The following document validates against this schema  {\n   name: {\n       first_name :  Gary ,\n       last_name :  Medel \n   },\n    age : 27,\n    club_name :  Inter de Milan \n}  By default the names specified under  properties  are not required, this means that, for example, the empty document   {}  validates against the schema   {\n     type :  object ,\n     properties : {\n         first : { type :  string },\n         last : { type :  string }\n    }\n}  For validation purproses the  properties  keyword should be understood as follows: if a document has a name/value pair  and  this name is specified in  properties , then the value of this pair needs to validate against the schema specified under this name in  properties .   Additional Properties  Note that  properties  does not state aything about the structure of any additional names not specified in this keyword. The  additionalProperties  keyword is used both to state if the document will support additional properties from the ones named on  properties  restriction and to give an schema for these extra properties. For example, lets see the following schema   {\n     type :  object ,\n     properties : {\n         first : { type :  string },\n         last : { type :  string }\n    },\n     additionalProperties : false\n}  In this case we are asking for documents that to don't have any properties whose keywords are different from \"first\" and \"last\". For instance, this document would not be valid:  {\n     first :  Gary ,\n     last :  Medel ,\n     age : 25\n}  Other use of  additionalProperties  is to restrict the structure of extra properties provided. For example, lets see the following schema   {\n     type :  object ,\n     properties : {\n         first : { type :  string },\n         last : { type :  string }\n    },\n     additionalProperties : {\n                              type :  integer \n                            }\n}  Here we are asking that any keywords different from \"first\" and \"last\" must have integer values. For example the next JSON document validates against the schema  {\n     first :  Gary ,\n     last :  Medel ,\n     age : 25\n}  But this one doesn't  {\n     first :  Gary ,\n     last :  Medel ,\n     age :  twenty five \n\n}  Number of Properties  The  minProperties and  maxProperties  keywords are used to restrict the number of properties allowed on a JSON object. For example, lets see the following schema   {\n     type :  object ,\n     minProperties : 3,\n     maxProperties : 5\n\n}  Here we are asking for JSON objects with at least 3 properties and no more than 5. For example this object would validate against the schema  {\n     first : 10,\n     second : 11,\n     third : 12,\n     four : 13\n}  but this one doesn't  {\n     first : 10,\n     second : 11\n}  Dependencies  Dependecies are used to modify the schema in function of the properties that de JSON object provides. There is two ways of doing this with  dependencies  keyword. The first one is used to force the presence of some properties if a particular keyword is provided by the object. Let's see the following example  {\n     type :  object ,\n     properties : {\n         first : { type :  string },\n         last : { type :  string },\n         team : { type :  string },\n         league : { type :  string }\n            },\n     required : [ first ,  last ],\n     dependencies :{\n                         team : [ league ]    \n                      }\n}  Here we are going to accept all schemas that contains the properties \"first\" and \"last\", but if the object has the property \"team\" then the property \"league\" becomes a required property. For example, this document is valid against the schema  {\n     first :  Gary ,\n     second :  Medel ,\n     team :  Inter de Milan ,\n     league :  Serie A \n}  but this one is not valid  {\n     first :  Gary ,\n     second :  Medel ,\n     team :  Inter de Milan \n}  The other way of using  dependencies  keyword is to ask the JSON object to satisfy another JSON Schema in the presence of certain keywords. Lets take the following schema as an example  {\n     type :  object ,\n     properties : {\n         first : { type :  string },\n         last : { type :  string },\n         team : { type :  string }\n            },\n     required : [ first ,  last ],\n     dependencies :{\n                         team : {\n                         properties : {\n                             league : { type :  string },\n                             goals : { type :  integer }\n                                         },\n                        required : [ league ,  goals ]\n                        }  \n                      }\n}  Here we ask the JSON object to have the properties \"league\" and \"goals\" in the presence of \"team\" property. For example the next object validates against the schema  {\n     first :  Gary ,\n     second :  Medel ,\n     team :  Inter de Milan ,\n     league :  Serie A ,\n     goals : 5\n}  But this one doesn't  {\n     first :  Gary ,\n     second :  Medel ,\n     team :  Inter de Milan ,\n     goals : 5\n}  Pattern Properties  Sometimes we will want to restrict a set of properties depending if they share a pattern on they keywords. The  patternProperties  keyword is used to restrict keywords matching to a certain regular expression. Let's see a example of this  {\n     type :  object ,\n     properties : {\n         first : { type :  string },\n         last : { type :  string },\n         team : { type :  string },\n         league : { type :  string }\n            },\n    patternProperties : {\n        _goals$ : {  type :  integer  }\n  }\n}  Here we are asking that properties matching the regular expression   _goals$  must be integers. For example the following JSON object validates against the schema  {\n     first :  Gary ,\n     second :  Medel ,\n     team :  Inter de Milan ,\n     league :  Serie A ,\n     league_goals : 5,\n     international_goals : 2\n}  but this one doesn't  {\n     first :  Gary ,\n     second :  Medel ,\n     team :  Inter de Milan ,\n     league :  Serie A ,\n     league_goals :  five \n}  Formal Specification  More formally, the correct grammar for these schemmas can be seen like this:  \n  objSch :=  objRes (,  objRes ) *   Here  objRes  is a restriction for objects such that every  objRes  must be different from each other in the schema and occurs no more than one time each. Each of these restrictions is defined as follows:  \n  arrRes  :=  typeObj  |  prop  |  addprop  |  req  |  minprop  |  maxprop  |  dep |  pattprop \n  typeObj  := \"type\": \"object\"\n  prop  := \"properties: \"{  kSch  (,  kSch ) * }\n  addprop  := \"additionalProperties\": (true | false | {  JSch  })\n  req  := \"required\": [  kword  (,  kword ) * ]\n  minprop  := \"minProperties: \" n\n  maxprop  := \"maxProperties: \" n\n  dep  := \"dependencies: \"( depArr  |  depSch )\n  depArr  := {  kArr  (,  kArr ) * }\n  depSch  := {  kSch  (,  kSch ) * }\n  kArr  :=  kword : [  kword  (,  kword ) * ]\n  pattprop  := \"patternProperties: \"{  patSch  (,  patSch ) * }\n  patSch  := regexp: {  JSch  }   Here n is a natural number and  JSch  a JSON Schema. Similarly  kSch  is a pair  keyword: schema .  Formal Validation  Let  O  be an object Schema and  J  a JSON document. We say that  J  validates against  O  if for each name/value pair  k  in  O  one of the following holds:   k  is  \"type\": \"object\"  and  J  is an object  k  is  \"properties\": {k 1 : s 1  , ... , k n : s n }  and  J  is an object that for each key-value pair  k': j'  in  J , if  k' = k i  for some i in [1 , ... , n] then  j'  satisfies  s i  k  is  \"additionalProperties\": false  and  J  is an object such that every keyword in  J  is mentioned in  \"properties\": {k 1 : s 1  , ... , k n : s n }  k  is  \"additionalProperties\": true  and  J  is an object  k  is  \"additionalProperties\": s  and  J  is an object that for each key-value pair  k': j'  in  J  such that  k'  is different from every  k i  in  \"properties\": {k 1 : s 1  , ... , k n : s n }  and  j'  satisfies  s  k  is  \"required\": [k 1  , ... , k n ]  and  J  is an object such that every keyword  k i  appears on  J  properties  k  is  \"minProperties\": n  and  J  is an object with at least n properties  k  is  \"maxProperties\": n  and  J  is an object with at most n properties  k  is  \"dependencies\": {k 1 : [k 1 ], ... , k n : [k n ]}  and  J  is an object such that if k i  appears on  J  then every keyword in [k i ] appears in  J  k  is  \"dependencies\": {k 1 : s 1  , ... , k n : s n }   and  J  is an object such that if k i  appears on  J  then  J  must satisfy  O  and s i  k  is  \"patternProperties\": {regexp 1 : s 1  , ... , regexp n : s n }  and  J  is an object that for each key-value pair  k': j'  in  J , if  k'  is in the language of  regexp i  for some i in [1,..., n] then  j'  satisfies  s i", 
            "title": "Object Schemas"
        }, 
        {
            "location": "/spec/combined_schemas/", 
            "text": "Combined Schemas\n\n\nSometimes we want to specify more complex constraints that require verifying if a document validates against multiple schemas. JSON Schema allows us to do so using the following keywords: \n\n\n\n\nanyOf\n, which forces the document to validate against \nat least one\n of the specified schemas\n\n\nallOf\n, which forces the document to validate against \nall\n of the specified schemas\n\n\noneOf\n, which forces the document to validate against \nprecisely one\n of the specified schemas.\n\n\n\n\nAdditionally, we can use:\n\n\n\n\nnot\n, which states that a document does \nnot\n validate against a specified schema.  \n\n\n\n\nBelow we describe each of the keywords in more detail.\n\n\nanyOf\n\n\nThe \nanyOf\n keyword is used to make  document validate against at least one of the listed schemas. For instance, if we were building an application that can accept either strings or integers we could use the following schema to check if the document is of the correct format.\n\n\n{\n  \"anyOf\": [\n    { \"type\": \"string\" }, \n    { \"type\": \"integer\" }\n  ]\n}\n\n\n\n\nIn this case JSON document \n\"This is a string\"\n satisfies the above schema, as does the document \n72\n. On the other hand \n7.42\n will not satisfy the schema, nor will the document \n{ \"name\": \"Gary\"}\n.\n\n\nallOf\n\n\nIn order to specify that our document has to conform to several different schemas we use the keyword \nallOf\n. For instance if we want to accept strings that are in the intersection of two regular expressions it is often simpler to validate against two different schemas than write a single regular expression denoting the intersection. The schema below validates against any string that is a gmail address and that contains a substring \njoe\n.\n\n\n{\n  \"allOf\": [\n    { \"type\": \"string\", \"pattern\": \"^.+@gmail.com$\" }, \n    { \"type\": \"string\", \"pattern\": \"^.*joe.*$\" }\n  ]\n}\n\n\n\n\nAlthough the example above looks somewhat superficial (and is indeed expressible without using the \nallOf\n keyword, as all basic examples of \nallOf\n are), the true usefulness of the \nallOf\n keyword becomes evident when combined with the \ndefinition\n and \n$ref\n keywords.\n\n\nNote that using \nallOf\n one can easily define schemas that do \nnot\n validate against any document. For instance the schema below requires the document to be both a string and an integer, which is clearly not possible.\n\n\n{\n  \"allOf\": [\n    { \"type\": \"string\" }, \n    { \"type\": \"integer\" }\n  ]\n}\n\n\n\n\noneOf\n\n\nWhen we want to validate against precisely one schema from a predefined set of schemas we use the \noneOf\n keyword. For instance if want to find numbers that are multiples of \n2\n or multiples of \n5\n, but not both at the same time we could use the following schema.\n\n\n{\n  \"oneOf\": [\n    { \"type\": \"integer\", \"multipleOf\": 2 }, \n    { \"type\": \"integer\", \"multipleOf\": 5}\n  ]\n}\n\n\n\n\nThis schema will validate against \n4\n and \n15\n, but it will not validate against \n10\n, as it satisfies both of the schemas. Equally, the schema will not validate against \n3\n, or any document that is not an integer.\n\n\nnot\n\n\nTo say that a document does not validate against a certain schema we use the \nnot\n keyword. For instance the schema below validates against any document that is not a string.\n\n\n{ \"not\": { \"type\": \"string\" } }  \n\n\n\n\nIt will accept the document \n4\n or \n{ \"name\": \"Gary\" }\n, but not \n\"name\"\n, or any other string.  \n\n\nFormal Specification\n\n\nCombined Schemas \ncombSch\n are formally specified using the following grammar.\n\n\n\n\ncombSch\n := \nallOf\n | \nanyOf\n| \noneOf\n | \nnot\n\n\nanyOf\n := \"anyOf\": [ { \nJSch\n } (, { \nJSch\n })* ]\n\nallOf\n := \"allOf\": [ { \nJSch\n } (, { \nJSch\n })* ]\n\noneOf\n := \"oneOf\": [ { \nJSch\n } (, { \nJSch\n })* ]\n\nnot\n := \"not\": { \nJSch\n }\n\n\n\n\nwhere \nJSch\n denotes an arbitrary JSON Schema.\n\n\nFormal Validation\n\n\nLet \nC\n be a Combined Schema and \nJ\n a JSON document. We say that \nJ\n validates against \nC\n if:\n\n\n\n\nC\n is of the form \n\"anyOf\": [{Sch\n1\n}, {Sch\n2\n}, ... ,{Sch\nn\n}]\n and \nJ\n conforms to \nsome\n \nSch\ni\n, for i=1...n\n\n\nC\n is of the form \n\"allOf\": [{Sch\n1\n}, {Sch\n2\n}, ... ,{Sch\nn\n}]\n and \nJ\n conforms to \nall\n of \nSch\ni\n, for i=1...n\n\n\nC\n is of the form \n\"oneOf\": [{Sch\n1\n}, {Sch\n2\n}, ... ,{Sch\nn\n}]\n and \nJ\n conforms to \nexactly one\n of \nSch\ni\n, for i=1...n\n\n\nC\n is of the form \n\"not\": {Sch}\n and \nJ\n does \nnot\n validate against \nSch\n.", 
            "title": "Combined Schemas"
        }, 
        {
            "location": "/spec/combined_schemas/#combined-schemas", 
            "text": "Sometimes we want to specify more complex constraints that require verifying if a document validates against multiple schemas. JSON Schema allows us to do so using the following keywords:    anyOf , which forces the document to validate against  at least one  of the specified schemas  allOf , which forces the document to validate against  all  of the specified schemas  oneOf , which forces the document to validate against  precisely one  of the specified schemas.   Additionally, we can use:   not , which states that a document does  not  validate against a specified schema.     Below we describe each of the keywords in more detail.", 
            "title": "Combined Schemas"
        }, 
        {
            "location": "/spec/combined_schemas/#anyof", 
            "text": "The  anyOf  keyword is used to make  document validate against at least one of the listed schemas. For instance, if we were building an application that can accept either strings or integers we could use the following schema to check if the document is of the correct format.  {\n  \"anyOf\": [\n    { \"type\": \"string\" }, \n    { \"type\": \"integer\" }\n  ]\n}  In this case JSON document  \"This is a string\"  satisfies the above schema, as does the document  72 . On the other hand  7.42  will not satisfy the schema, nor will the document  { \"name\": \"Gary\"} .", 
            "title": "anyOf"
        }, 
        {
            "location": "/spec/combined_schemas/#allof", 
            "text": "In order to specify that our document has to conform to several different schemas we use the keyword  allOf . For instance if we want to accept strings that are in the intersection of two regular expressions it is often simpler to validate against two different schemas than write a single regular expression denoting the intersection. The schema below validates against any string that is a gmail address and that contains a substring  joe .  {\n  \"allOf\": [\n    { \"type\": \"string\", \"pattern\": \"^.+@gmail.com$\" }, \n    { \"type\": \"string\", \"pattern\": \"^.*joe.*$\" }\n  ]\n}  Although the example above looks somewhat superficial (and is indeed expressible without using the  allOf  keyword, as all basic examples of  allOf  are), the true usefulness of the  allOf  keyword becomes evident when combined with the  definition  and  $ref  keywords.  Note that using  allOf  one can easily define schemas that do  not  validate against any document. For instance the schema below requires the document to be both a string and an integer, which is clearly not possible.  {\n  \"allOf\": [\n    { \"type\": \"string\" }, \n    { \"type\": \"integer\" }\n  ]\n}", 
            "title": "allOf"
        }, 
        {
            "location": "/spec/combined_schemas/#oneof", 
            "text": "When we want to validate against precisely one schema from a predefined set of schemas we use the  oneOf  keyword. For instance if want to find numbers that are multiples of  2  or multiples of  5 , but not both at the same time we could use the following schema.  {\n  \"oneOf\": [\n    { \"type\": \"integer\", \"multipleOf\": 2 }, \n    { \"type\": \"integer\", \"multipleOf\": 5}\n  ]\n}  This schema will validate against  4  and  15 , but it will not validate against  10 , as it satisfies both of the schemas. Equally, the schema will not validate against  3 , or any document that is not an integer.", 
            "title": "oneOf"
        }, 
        {
            "location": "/spec/combined_schemas/#not", 
            "text": "To say that a document does not validate against a certain schema we use the  not  keyword. For instance the schema below validates against any document that is not a string.  { \"not\": { \"type\": \"string\" } }    It will accept the document  4  or  { \"name\": \"Gary\" } , but not  \"name\" , or any other string.", 
            "title": "not"
        }, 
        {
            "location": "/spec/combined_schemas/#formal-specification", 
            "text": "Combined Schemas  combSch  are formally specified using the following grammar.   combSch  :=  allOf  |  anyOf |  oneOf  |  not  anyOf  := \"anyOf\": [ {  JSch  } (, {  JSch  })* ] allOf  := \"allOf\": [ {  JSch  } (, {  JSch  })* ] oneOf  := \"oneOf\": [ {  JSch  } (, {  JSch  })* ] not  := \"not\": {  JSch  }  where  JSch  denotes an arbitrary JSON Schema.", 
            "title": "Formal Specification"
        }, 
        {
            "location": "/spec/combined_schemas/#formal-validation", 
            "text": "Let  C  be a Combined Schema and  J  a JSON document. We say that  J  validates against  C  if:   C  is of the form  \"anyOf\": [{Sch 1 }, {Sch 2 }, ... ,{Sch n }]  and  J  conforms to  some   Sch i , for i=1...n  C  is of the form  \"allOf\": [{Sch 1 }, {Sch 2 }, ... ,{Sch n }]  and  J  conforms to  all  of  Sch i , for i=1...n  C  is of the form  \"oneOf\": [{Sch 1 }, {Sch 2 }, ... ,{Sch n }]  and  J  conforms to  exactly one  of  Sch i , for i=1...n  C  is of the form  \"not\": {Sch}  and  J  does  not  validate against  Sch .", 
            "title": "Formal Validation"
        }, 
        {
            "location": "/spec/definitions_references/", 
            "text": "Definitions \n References\n\n\nSubtitle", 
            "title": "Definitions & References"
        }, 
        {
            "location": "/spec/definitions_references/#definitions-references", 
            "text": "Subtitle", 
            "title": "Definitions &amp; References"
        }, 
        {
            "location": "/spec/generic_keywords/", 
            "text": "Generic Keywords\n\n\nJSON Schemas also support keywords that may apply to any JSON type. In this section we will provide the correct use and syntax of these keywords.\n\n\nEnumerated Values\n\n\nThe \nenum\n keyword restricts JSON instances to have certain values specified on the value of the operator. Let's take a look the following example:\n\n\n{\n \ntype\n: \nstring\n,\n \nenum\n: [\nInter Milan\n, \nAC Milan\n, \nJuventus\n, \nRoma\n]\n}\n\n\n\n\nHere we are asking for exclusively JSON strings with the values \"Inter Milan\", \"AC Milan\", \"Juventus\" or \"Roma\". For example the next JSON instance validates against the schema\n\n\nAC Milan\n\n\n\n\n\nBut this one doesn't\n\n\nFiorentina\n\n\n\n\n\nFurthermore, we may give different types values to the list\n\n\n{\n \nenum\n: [\nTwo\n, 2, true, null]\n}\n\n\n\n\nThe following JSON validates against the  schema\n\n\nnull\n\n\n\n\nBut this one doesn't\n\n\n16\n\n\n\n\nFormal Specification\n\n\nThe \nenum\n restriction is formally specified using the following grammar.\n\n\n\n\nenum\n := \"enum\": [\nJval\n (, \nJval\n)\n*\n]\n\n\n\n\nWhere \nJval\n can be either a \nnumber\n, a \nstring\n, an \nobject\n, an \narray\n, a \nboolean\n or a \nnull\n value. Note that each \nJval\n must be different from each other.\n\n\nFormal Validation\n\n\nLet \nS\n be Schema and \nJ\n a JSON document. We say that \nJ\n validates against \nS\n if the following holds:\n\n\n\n\nS\n has the restriction \n\"enum\": [val\n1\n , ... , val\nn]\n and \nJ\n is any val\ni\n for some i in [1 , ..., n].\n\n\n\n\nMetadata\n\n\nThese keywords just represent metadata of the schema and don't have a very strong semantic. However,they are good practices both for programmers and users to provide. These keywords can be either \ntitle\n, \ndescription\n, \ndefault\n or \n$schema\n. Let's take a look to the following example\n\n\n{\n    \n$schema\n: \nhttp://json-schema.org/draft-04/schema#\n,\n    \ntitle\n: \nPlayer schema\n,\n    \ndescription\n: \nThis schema accepts soccer players\n,\n    \ndefault\n: null,\n    \ntype\n: \nobject\n,\n    \nproperties\n: {\n        \nfirst_name\n: { \ntype\n: \nstring\n },\n        \nlast_name\n: { \ntype\n: \nstring\n },\n        \nage\n: { \ntype\n: \ninteger\n },\n        \nclub\n: {\n            \ntype\n: \nobject\n,\n            \nproperties\n: {\n                \nname\n: { \ntype\n: \nstring\n },\n                \nfounded\n: { \ntype\n: \ninteger\n }\n            },\n            \nrequired\n: [\nname\n]\n        }\n    },\n    \nrequired\n: [\nfirst_name\n, \nlast_name\n, \nage\n, \nclub\n]\n}\n\n\n\n\n\nFirst, the \n$schema\n keyword specifies that the current schema follows the specification of the version 3 of JSON Schema. We can provide different versions deppending of our requirements. The \ntitle\n keyword is useful to give a name to the schema. Similarly, the \ndescription\n keyword is useful to give a short description of what kind of documents the schema will accept. Finally the \ndefault\n keyword can be used to specify a default value for the document if an hipothetical validator reads a missing value as input.", 
            "title": "Generic Keywords"
        }, 
        {
            "location": "/spec/generic_keywords/#generic-keywords", 
            "text": "JSON Schemas also support keywords that may apply to any JSON type. In this section we will provide the correct use and syntax of these keywords.", 
            "title": "Generic Keywords"
        }, 
        {
            "location": "/spec/generic_keywords/#enumerated-values", 
            "text": "The  enum  keyword restricts JSON instances to have certain values specified on the value of the operator. Let's take a look the following example:  {\n  type :  string ,\n  enum : [ Inter Milan ,  AC Milan ,  Juventus ,  Roma ]\n}  Here we are asking for exclusively JSON strings with the values \"Inter Milan\", \"AC Milan\", \"Juventus\" or \"Roma\". For example the next JSON instance validates against the schema  AC Milan   But this one doesn't  Fiorentina   Furthermore, we may give different types values to the list  {\n  enum : [ Two , 2, true, null]\n}  The following JSON validates against the  schema  null  But this one doesn't  16  Formal Specification  The  enum  restriction is formally specified using the following grammar.   enum  := \"enum\": [ Jval  (,  Jval ) * ]  Where  Jval  can be either a  number , a  string , an  object , an  array , a  boolean  or a  null  value. Note that each  Jval  must be different from each other.  Formal Validation  Let  S  be Schema and  J  a JSON document. We say that  J  validates against  S  if the following holds:   S  has the restriction  \"enum\": [val 1  , ... , val n]  and  J  is any val i  for some i in [1 , ..., n].", 
            "title": "Enumerated Values"
        }, 
        {
            "location": "/spec/generic_keywords/#metadata", 
            "text": "These keywords just represent metadata of the schema and don't have a very strong semantic. However,they are good practices both for programmers and users to provide. These keywords can be either  title ,  description ,  default  or  $schema . Let's take a look to the following example  {\n     $schema :  http://json-schema.org/draft-04/schema# ,\n     title :  Player schema ,\n     description :  This schema accepts soccer players ,\n     default : null,\n     type :  object ,\n     properties : {\n         first_name : {  type :  string  },\n         last_name : {  type :  string  },\n         age : {  type :  integer  },\n         club : {\n             type :  object ,\n             properties : {\n                 name : {  type :  string  },\n                 founded : {  type :  integer  }\n            },\n             required : [ name ]\n        }\n    },\n     required : [ first_name ,  last_name ,  age ,  club ]\n}  First, the  $schema  keyword specifies that the current schema follows the specification of the version 3 of JSON Schema. We can provide different versions deppending of our requirements. The  title  keyword is useful to give a name to the schema. Similarly, the  description  keyword is useful to give a short description of what kind of documents the schema will accept. Finally the  default  keyword can be used to specify a default value for the document if an hipothetical validator reads a missing value as input.", 
            "title": "Metadata"
        }
    ]
}